<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiwan.github.io</id>
    <title>Keep Thinking</title>
    <updated>2019-10-29T07:57:56.383Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiwan.github.io"/>
    <link rel="self" href="https://xiwan.github.io/atom.xml"/>
    <subtitle>有美人兮心不怿</subtitle>
    <logo>https://xiwan.github.io/images/avatar.png</logo>
    <icon>https://xiwan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Keep Thinking</rights>
    <entry>
        <title type="html"><![CDATA[steam真的挂了2小时]]></title>
        <id>https://xiwan.github.io/post/steam-zhen-de-gua-liao-2-xiao-shi</id>
        <link href="https://xiwan.github.io/post/steam-zhen-de-gua-liao-2-xiao-shi">
        </link>
        <updated>2019-10-29T07:30:59.000Z</updated>
        <content type="html"><![CDATA[<p>早上一起来被告知昨晚有将近两个小时的游戏服务器连接失败。大概的样子是这样：</p>
<figure data-type="image" tabindex="1"><img src="https://xiwan.github.io/post-images/1572334369507.png" alt=""></figure>
<p>第一排查的是机房网络情况，经过询问得知网络正常。然后开始分析日志，发现如下特点：</p>
<ol>
<li>连接失败的开始时间和结束时间差不多（夜里2点-4点）</li>
<li>两个机房都出现了上面的情况（国内，国外）</li>
</ol>
<p>根据以上两条进一步分析，机房的网络问题被排除了。</p>
<p>排除掉机房后，我又看了下当时的cpu内存情况也没有异常。接下来只能重新掉头分析上报内容了，感觉大部分失败都是在登陆界面。游戏内玩家报告失败的情况没有。这个时候反应是不是steam平台炸了。但是这个怎么验证呢？这么大的平台炸了，为啥网上没有一点消息。。。</p>
<p>接着只能硬着头皮查日志了</p>
<figure data-type="image" tabindex="2"><img src="https://xiwan.github.io/post-images/1572334817578.png" alt=""></figure>
<p>根据日志这段时间分析也发现了几个特点：</p>
<pre><code>1. 两个机房出现情况的时间点不单单是差不多，而是精确到秒级别的同步。
2. 一般的超时差不多就是几百毫秒，这段时间的超时居然高达了100秒。
</code></pre>
<p>根据1来推断有两种可能性。第一种是我们又被攻击了，不过我很快否定了这个想法。因为攻击不可能挑选半夜人少时候，并且只持续了2小时左右就停止了，这个不大符合规律。那么就是最不可能的肯能了：steam平台昨晚挂了。</p>
<p>steam平台有波动是很正常，但2个小时的时间算是一个不小的事故了。会不会是因为某次波动导致的底层bug，从而请求阻塞之类？不过经过老板提点，还是否定了这个思路，因为两个机房，相同的时间节点。由于两边环境的差异，不可能这么凑巧的。所以真相只有一个：steam 挂了2小时。</p>
<p>顺着这个思路，我终于找到了一个作证：</p>
<figure data-type="image" tabindex="3"><img src="https://xiwan.github.io/post-images/1572335271678.png" alt=""></figure>
<p>相关网站 https://outage.report/steam 。这个是一个专门给玩家们上报steam 挂机了的网站。报告的热点图几乎都在北美和欧洲，国内似乎知道的人很少，并且由于出问题时间在半夜，所以并没有人会怀疑到steam上面去。</p>
<p>这下一切就解释得通了：steam昨晚真得挂了2个小时！根据宕机历史来看，steam不算太靠谱。。。</p>
<h2 id="隐患">隐患</h2>
<p>当解决完上面的疑惑后，还有一个问题：为啥steam宕机时候我们居然挂机了100秒？幸亏这个问题是半夜发生，如果是高峰期，可能直接导致游戏内玩家都会无法使用。这也算是一个比较大的隐患了。当然，最后解决这个问题是比较简单，重新设置下timeout和readwritetimeout时间就好了。</p>
<p>对于request里面给的解释：</p>
<pre><code>timeout 相当于请求发出到建立连接所花费的时间，默认100秒
readwritetimeout 相当于建立连接到下载完整个包体需要的时间，默认300秒
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最近...]]></title>
        <id>https://xiwan.github.io/post/zui-jin</id>
        <link href="https://xiwan.github.io/post/zui-jin">
        </link>
        <updated>2019-10-11T07:58:54.000Z</updated>
        <summary type="html"><![CDATA[<p>这一个月经过努力好不容易把我们的游戏送上了steam。中间踩了不少坑，无数次的加班才换来的结果。当然现在回国头去看一切还是挺值的。游戏在没有任何推广情况下，口碑和数据都保持得不错。每天在留言板和q群里面看玩家和我们的互动也慢慢成为我得日常部分。今天好不容易闲下来了一点，对过去一段时间做个回顾看看</p>
]]></summary>
        <content type="html"><![CDATA[<p>这一个月经过努力好不容易把我们的游戏送上了steam。中间踩了不少坑，无数次的加班才换来的结果。当然现在回国头去看一切还是挺值的。游戏在没有任何推广情况下，口碑和数据都保持得不错。每天在留言板和q群里面看玩家和我们的互动也慢慢成为我得日常部分。今天好不容易闲下来了一点，对过去一段时间做个回顾看看</p>
<!-- more -->
<h2 id="游戏方面">游戏方面</h2>
<p>首先steam这个平台对于我们这种小团队来说是当前来说比较好的选择。由于大环境的影响，手游的排期一直在等消息。投资人也是急于将我们游戏变现一部分来度过寒冬。前面3次测试我们还算是稳扎稳打，手机上数据不算经验但也能交代。中途突然说我们改方向去PC，其实团队还是很担忧的。毕竟PC的玩家和手机并不能算完全重合的一波人。需要为PC做很多改动，让它看起来不是那么的手游。玩法上的调整也是一个挑战。</p>
<p>总的说来就是时间紧任务急。这段时间团队不少人996来赶进度。当然老板也是挺拼的一人，这里要着重说下，几乎所有的游戏玩法和服务器逻辑部分都是他在搞。那么我在干嘛？哈哈哈。我现在算是这个小团队的技术负责人，是在做很多看不见的部分，游戏底层的架构，高并发，日志收集分析和运维自动化之类，当然包括很多团队都头疼的平台接入。小公司并没有特别富裕的人手，并且很多人还良莠不齐。所以这些东西都需要我自己来搞。</p>
<p>大概讲下我的一些做法吧。</p>
<h3 id="底层部分">底层部分</h3>
<p>这边游戏底子是C#写的，方便前后端公用些公共库。但不好是老板写这些东西时候都是东平西凑加上自己的积累写的一套底层协议。只是看上去可以用而已，经常会出现一些诡异的问题。比如第一次测试就发现服务器经常不响应，然后得手动重启机器。不过好在老板本身还是认识到了这个问题，并没有执着于过去得经验。我过来的第一件事情就是整理这个部分。</p>
<p>自己认为经验还是可以，所以先自己是用jmeter做了套压测系统来做各种关键接口的评测。后面又找了dotnetty来替换底层进行新的一轮压测。用数据说话来证明野路子只是能用，但没法长久用。当然这个部分也是前前后后搞了我一个多月才完成。事实证明这个替换是值得的，在我们第三次测试时候我们就顺利抗住了大量玩家的请求。</p>
<p>当然对于一些中间件的使用我还是比较有话语权的，尤其是redis部分。感觉刚开始老板的用法都是极其粗暴简单，基本就是用下hash, string之类，复杂的结构几乎不触及。处于一个知其然但不知其所以然的状态。这都是小团队的痛楚。反正就是这么一点点磨啊磨，现在也开始有点像模像样了吧。</p>
<p>总结下来：如果你不是天才，请不要相信自己造轮子的能力，因为前路崎岖且慢慢。</p>
<h3 id="日志部分">日志部分</h3>
<p>同样老的做法是记录好日志后，导入mysql，然后写各种查询。但同样由于不深入研究这个东西得化，没法抗住海量日志的。我一开始也是挠头，幸好在前面公司有看他们使用过ELK。于是就硬着头皮啃下来了这个部分。现在回头看，从最简单的demo跑通，到现在做到了集群分布。这中间的坑也是踩了不少。比如原来日志格式在logstash中需要自己手动写分析规则，elasticsearch那些恶心的查询语句，当然少不了调优参数时候各种痛苦。</p>
<p>现在出来的效果还是不错的，团队成员也基本适应了如何进行简单检索，我们也抗过了亿级别的日志流量。当然我自己也很习惯在上面做二次开发，做各种维度的日志分析了。</p>
<h3 id="自动化">自动化</h3>
<p>这个其实也是慢慢发现的。刚开始我需要去接一个渠道的包，然后这个手动过程异常恶心。通常打一个包需要一个多小时。当然以前我就知道这个东西恶心了，之前的团队我并不需要搞，而是由专门的“包王”来处理。</p>
<p>作为程序的我，干了几次就不舒服了。这lifestyle也太差了！幸好我对于脚本还比较在行，由于大环境我们也是从windows往linux转，所以我索性开始用脚本记录自己的操作步骤了。接着慢慢又引入了jenkins这个东西，一切都顺理成章的这么发生了。现在团队的前台后台所有的程序包都通过自动化来控制，无疑大大地解放了生产力。我现在要做地也只是教会他们如何选择下拉框而已。</p>
<p>在做自动化过程中我还培养了出来一个算可以的运维人员，从linux不懂，到现在也能产出不少脚本了。自然也解放了我不少的精力。同时也不用我半夜起来对接运营了。</p>
<p>自动化其实是一种体系，并不是一个脚本两个脚本就算自动化了。简单脚本其实是只能算小工具的。这中间需要吃透管理，架构，甚至一些人性来做。我自己也算是摸索到了一些思路。以后倒可以开篇说。</p>
<h3 id="测试">测试</h3>
<p>这也是一个项目能否走远的重要保障。但小团队往往都是最后一天才交货，认为自己写完了就算功能完了，甚至连基本的自测都没有。随便使用一个小的bug工具就算有管理了。感觉就是有点自欺欺人吧。我来这边后显示把后台重要接口都压测一遍，然后对于前端的要求就是：重要的基础功能要自己写用例自己来测试，并且我都会盯着看。因为越是那些底层的越容易忽视，比如偶尔出现的连不上去啊，或者网络交互的不稳定啊。其实总结下来：就是测试不到位，自己很多逻辑上的漏洞都没有发现。为了改变这个现状，我把重要的基础功能都用showdoc清楚的设计出来，用例也严格按照这个写。终于前面2测发现的很多制命问题，在第三测都没有了。也算是长须了一口气。</p>
<h3 id="管理">管理</h3>
<p>这个部分对于一直写代码的我来说并不是特别在行。我也会套用一些敏捷的原则，指定主从分支，版本号管理，提交节点之类的东西。但怎么说呢？效果不好。尤其是在小团队上面，人员精神面貌和积极性就摆在那里。这个东西关键靠的是执行。所以一旦碰上点业务忙就容易把之前的节奏打乱。我还是属于那种比较佛系思维的人，所以干了一阵子还是去找了专业项目经理来比较好。</p>
<h2 id="总结">总结</h2>
<p>写了一大通，感觉有点牢骚表现。毕竟自己当初脑子一热从明星上市企业出来，追求自己的游戏梦吧。结果这一年多下来做的还是更偏底层的东西了。中间有一段时间我自己还是有些执念。自己会学习Unity之类的东西，写各种最后无疾而终的小游戏。可能还是有想法哪天自己可以写写酷炫的前端吧（应该没啥问题😁）</p>
<p>反正就这么过来了，现在游戏的上线，更感觉是自己是幕后的扫地僧。虽然感觉不出来游戏中的贡献，但正如老板说的：没我这游戏出不来。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker 日志处理]]></title>
        <id>https://xiwan.github.io/post/docker-ri-zhi-chu-li</id>
        <link href="https://xiwan.github.io/post/docker-ri-zhi-chu-li">
        </link>
        <updated>2019-09-18T03:59:22.000Z</updated>
        <summary type="html"><![CDATA[<p>docker 启动后有一个需求便是如何处理以及收集它产生的日志。<br>
这里的日志可以分为3类： docker的引擎日志， docker 容器日志， docker 应用日志</p>
]]></summary>
        <content type="html"><![CDATA[<p>docker 启动后有一个需求便是如何处理以及收集它产生的日志。<br>
这里的日志可以分为3类： docker的引擎日志， docker 容器日志， docker 应用日志</p>
<!-- more -->
<h3 id="docker-引擎日志">docker 引擎日志</h3>
<p>这个查找了写文章后总结如下，根据自己对应的系统去查找即可</p>
<p><strong>Ubuntu(14.04)</strong>	/var/log/upstart/docker.log<br>
<strong>Ubuntu(16.04)</strong>	journalctl -u docker.service<br>
<strong>CentOS 7/RHEL 7/Fedora</strong>	journalctl -u docker.service<br>
<strong>CoreOS</strong>	journalctl -u docker.service<br>
<strong>OpenSuSE</strong>	journalctl -u docker.service<br>
<strong>OSX</strong>	~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/log/d‌​ocker.log<br>
<strong>Debian GNU/Linux 7</strong>	/var/log/daemon.log<br>
<strong>Debian GNU/Linux 8</strong>	journalctl -u docker.service<br>
<strong>Boot2Docker</strong>	/var/log/docker.log</p>
<h3 id="docker-容器日志">docker 容器日志</h3>
<p>容器的日志 则可以通过 docker logs 命令来访问，而且可以像 tail -f 一样，使用 docker logs -f 来实时查看。如果使用 Docker Compose，则可以通过 docker-compose logs &lt;服务名&gt; 来查看。</p>
<p>如果需要查看容器日志的具体位置可以调用命令：<br>
<img src="https://xiwan.github.io/post-images/1568779631501.png" alt=""></p>
<p>可以看到这个是一个非常复杂的路径，每次看这个文件是非常不方便的。比较好的解决方案是用一个日志收集器来收集这些日志，比如利用<a href="https://tonybai.com/2016/03/25/ship-docker-container-log-with-filebeat/">filebeat</a>来收集日志，然后集中到ES中查询。不过需要一些软件安装或者配置。</p>
<p>这里我使用一个比较简单的方案， 利用docker-compose 的logs命令将对应service输出到默认的位置。这样不用担心频繁的up down导致的容器号变化。</p>
<pre><code>nohup docker-compose -f docker-compose-esk.yml logs -f kibana &gt;&gt; /data/game/logs/elk/VM_18_7_centos-kibana.log &amp;
</code></pre>
<p>当然，不同机器上的日志可以通过定时rsync命令拉取到同一台机器方便查找。</p>
<h3 id="docker应用日志">docker应用日志</h3>
<p>由于docker是无状态的，可以通过volums来实现和宿主机的互通。我们可以将docker内应用日志和数据方便地放在宿主机管理，比较简单。可以同时在宿主机上启动一个filebeat将日志发送到内部es机器即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何接入支付]]></title>
        <id>https://xiwan.github.io/post/ru-he-jie-ru-zhi-fu</id>
        <link href="https://xiwan.github.io/post/ru-he-jie-ru-zhi-fu">
        </link>
        <updated>2019-09-04T07:41:37.000Z</updated>
        <summary type="html"><![CDATA[<p>对于自定地图来说，接入支付应该是比不可少的步骤。这里主要以支付宝为例子来说明下大概流程</p>
]]></summary>
        <content type="html"><![CDATA[<p>对于自定地图来说，接入支付应该是比不可少的步骤。这里主要以支付宝为例子来说明下大概流程</p>
<!-- more -->
<h3 id="主体流程">主体流程</h3>
<figure data-type="image" tabindex="1"><img src="https://xiwan.github.io/post-images/1567582907291.png" alt=""></figure>
<h4 id="预支付部分">预支付部分</h4>
<ol>
<li>ui界面发起向lua服务器的支付请求，同时监听支付返回事件。</li>
<li>lua服务器调用游戏服务器支付api，这里一般使用的是CreateHTTPRequestScriptVM 方法来拉起http请求。具体用法建议参考其他项目。</li>
<li>游戏服务器接入好支付sdk后，通过sdk的api拉起预支付请求（如何配置可以参考网上很多例子）。如果是java的服务器代码，就调用 AlipayTradePrecreateRequest 接口就好了。同时也可以在这里完成创建订单的操作。</li>
<li>同步等待平台预支付结果。</li>
<li>这里可以根据返回结果来做一些数据更新的操作。然后将二维码地址告知lua服务器端。</li>
<li>lua服务器获取到预支付的结果，告知ui界面展示二维码。</li>
</ol>
<h4 id="支付部分">支付部分</h4>
<ol start="7">
<li>客户扫描二维码，与平台交互支付过程。</li>
<li>支付成功后，平台返回结果给客户</li>
<li>同时，平台会异步告知交易结果给游戏服务器。游戏服务器继续完成数据更新操作。</li>
<li>似乎没啥用。</li>
</ol>
<h4 id="测试结果">测试结果</h4>
<figure data-type="image" tabindex="2"><img src="https://xiwan.github.io/post-images/1567582911160.png" alt=""></figure>
<h4 id="注意">注意</h4>
<p>如果使用沙箱环境，要注意签名方式和对应的公钥不要弄错。就支付宝来说，需要记录两个公钥，一个是与签名方式对应的应用公钥，还有一个是基于这个公钥签发的平台公钥。</p>
<p>还有一点就是支付参数中的product_code部分需要根据签约的活动来写，不能乱写。否则会一直导致参数失败的错误。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[制作一个KV编辑器]]></title>
        <id>https://xiwan.github.io/post/zhi-zuo-yi-ge-kv-bian-ji-qi</id>
        <link href="https://xiwan.github.io/post/zhi-zuo-yi-ge-kv-bian-ji-qi">
        </link>
        <updated>2019-08-28T11:12:37.000Z</updated>
        <summary type="html"><![CDATA[<p>为了后面方便快速开发自定义英雄和技能，决定开坑先做个KV编辑器。有依赖一个第三方的库来实例化KV。</p>
]]></summary>
        <content type="html"><![CDATA[<p>为了后面方便快速开发自定义英雄和技能，决定开坑先做个KV编辑器。有依赖一个第三方的库来实例化KV。</p>
<!-- more -->
<h3 id="主要功能">主要功能</h3>
<p>[系统]<br>
1. 	设置： 一些全局参数<br>
默认打开位置（英雄，技能，物品）<br>
默认文件名字（英雄，技能，物品）<br>
导入基础数据<br>
2.  关于<br>
[编辑]<br>
[英雄]<br>
1. 	导入：读取一些已经写好的KV文件<br>
2. 	新建：创建一个新的KV<br>
[技能]<br>
1. 	导入：读取一些已经写好的KV文件<br>
2. 	新建：创建一个新的KV<br>
[物品]<br>
1. 	导入：读取一些已经写好的KV文件<br>
2. 	新建：创建一个新的KV<br>
[字典]<br>
翻译官方的一些文档</p>
<h3 id="excel">excel</h3>
<p>为了快速反应基础的变化，需要一个基于excel导入的数据库。这样可以很方便地导入导出。<br>
通用的结构：</p>
<ul>
<li>ID: 主要是标识用</li>
<li>KEY: 内置KEY名字，在输入时候会进行智能匹配 (如果是#开头，表示需要从POINT范围选取)</li>
<li>GROUP: 分组用，方便展示或者其他目的</li>
<li>VALUE: 从官方搞的一些默认值</li>
<li>COMMENT: 收集的一些说明</li>
<li>PARENT: 表明KEY之间的父子关系</li>
<li>POINT: KV的取值源头（比如DOTA_ABILITY_ATTRIBUTE#DOTAUnitAttackCapability_t  表示查看比如DOTA_ABILITY_ATTRIBUTE表的DOTAUnitAttackCapability_t的分组）</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://xiwan.github.io/post-images/1567421279321.png" alt=""></figure>
<h3 id="截图">截图</h3>
<figure data-type="image" tabindex="2"><img src="https://xiwan.github.io/post-images/1566991427426.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[bot相关]]></title>
        <id>https://xiwan.github.io/post/bot-xiang-guan</id>
        <link href="https://xiwan.github.io/post/bot-xiang-guan">
        </link>
        <updated>2019-08-26T07:35:31.000Z</updated>
        <summary type="html"><![CDATA[<p>通常测试时候是需要加入一些机器人的。那么在workshop中如何加入呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>通常测试时候是需要加入一些机器人的。那么在workshop中如何加入呢？</p>
<!-- more -->
<h3 id="与bot相关的几个函数">与bot相关的几个函数</h3>
<p>int GetConnectionState(int iPlayerID)</p>
<p><code>Returns a status code indication the connection state of the player. 0 - no connection. 1 - bot connected. 2 - player connected. 3 bot/player disconnected.</code></p>
<p>bool IsControllableByAnyPlayer()</p>
<p><code>Is this unit controlled by any non-bot player?</code></p>
<p>bool IsOwnedByAnyPlayer()</p>
<p><code>Is this unit owned by any non-bot player?</code></p>
<p>void SetBotDifficulty(int nDifficulty)</p>
<p><code>Sets the bot's difficulty level (0 = passive, 1 = easy, 2 = medium, 3 = hard, 4 = unfair)</code></p>
<figure data-type="image" tabindex="1"><img src="https://xiwan.github.io/post-images/1566805414719.png" alt=""></figure>
<p>bool AddBot(string string_1, string string_2, string string_3, bool bool_4)</p>
<p><code>Add a computer controlled bot.</code></p>
<h3 id="addbot用法">AddBot用法</h3>
<p>这里面比较重要的就是AddBot方法了。<br>
string_1 = 英雄单位的名字（默认的和自定义应该都是可以的）<br>
string_2 = 英雄位置（mid, top, bot）三条线的分路<br>
string_3 = passive/positive ？？<br>
bool_4 = 这个表示是否和玩家为队友，但可以不在一个阵营</p>
<p>如果要设置阵营，需要调用</p>
<pre><code>PlayerResource:SetCustomTeamAssignment( 0, DOTA_TEAM_GOODGUYS )
PlayerResource:SetCustomTeamAssignment( 1, DOTA_TEAM_GOODGUYS )
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://xiwan.github.io/post-images/1566806951528.png" alt=""></figure>
<p>当然，我可以枚举上面的组合来达到一下效果：同阵营队友，同阵营非队友，不同阵营队友，不同阵营非队友之类。</p>
<p>最终效果，不通阵营的队友，互相不能攻击</p>
<figure data-type="image" tabindex="3"><img src="https://xiwan.github.io/post-images/1566807155157.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何跳过heroselection]]></title>
        <id>https://xiwan.github.io/post/ru-he-tiao-guo-heroselection</id>
        <link href="https://xiwan.github.io/post/ru-he-tiao-guo-heroselection">
        </link>
        <updated>2019-08-20T11:57:47.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>最近研究dota2rpg时候发现一个问题：游戏流程如果使用官方的做法会比较死板。比如你必须选完队伍，然后再去选择英雄，然后再开始游戏。当然这个不是说它不好，但对于一款高度定制化的地图编辑器来说，这着实会束缚开发者的能力。很多优秀的rpg地图都可以定制整个游戏前的流程。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>最近研究dota2rpg时候发现一个问题：游戏流程如果使用官方的做法会比较死板。比如你必须选完队伍，然后再去选择英雄，然后再开始游戏。当然这个不是说它不好，但对于一款高度定制化的地图编辑器来说，这着实会束缚开发者的能力。很多优秀的rpg地图都可以定制整个游戏前的流程。</p>
<!-- more -->
<h3 id="调查">调查</h3>
<p>首先，最重要的是搞清楚已有的dota游戏流程是如何的。<br>
<img src="https://xiwan.github.io/post-images/1566368060441.png" alt=""><br>
可以看到整个流程还是比较详细的，也容易看懂。其中比较重要的就是game_setup和hero_selection了。</p>
<p>一般来说要修改game_setup界面还是比较简单的。比如：</p>
<pre><code>	&lt;Panel&gt;
		&lt;!-- Ingame HUD --&gt;
		&lt;CustomUIElement type=&quot;GameSetup&quot; layoutfile=&quot;file://{resources}/layout/custom_game/team_selection.xml&quot; /&gt;
	&lt;/Panel&gt;
</code></pre>
<p>同理我们也可以添加</p>
<pre><code>&lt;CustomUIElement type=&quot;HeroSelection&quot; layoutfile=&quot;file://{resources}/layout/custom_game/pick_hero.xml&quot; /&gt;
</code></pre>
<p>这样来达到自定义界面的效果。<br>
当我尝试出来效果一般。首先按照这个思路我们还是必须严格按照流程来进行界面设置。也就是必须设置完了队伍再去选择英雄之类。那如果游戏的设定不希望是这个流程呢？其次感觉要覆盖掉原来的英雄选择界面比较麻烦。我摸索出来的思路就是一个覆盖而已，效果如下：</p>
<figure data-type="image" tabindex="1"><img src="https://xiwan.github.io/post-images/1566369563083.png" alt=""></figure>
<h3 id="跳出盒子">跳出盒子</h3>
<p>有没有可能我在game_setup里面就直接做完了所有的事情呢。这样的话我们就不必完全按照预设的流程。</p>
<h4 id="准备工作">准备工作：</h4>
<p>我们需要让game_setup不往hero_selection走。那么需要这么设置：</p>
<pre><code>function COverthrowGameMode:OnGameRulesStateChange()
	local nNewState = GameRules:State_Get()

	-- Disable auto launch when entering custom game setup, it can be
	-- re-enabled at any point later while still in custom game setup
	if nNewState == DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP then
		GameRules:EnableCustomGameSetupAutoLaunch( false )
	end
end
</code></pre>
<p>这样就不会发生跳转了。</p>
<p>接下来的问题是：我们可以自己做一个英雄界面(或者其他准备界面)，但怎么跳过默认的hero_selection？官网并没提供可以跳过某个步骤的接口。就是说按照dota2底层实现它是必须严格按照上面的顺序来做的。</p>
<p>经过摸索，其实道理很简单。为什么默认机制是会强行你进入hero_selection?那是因为你没有英雄。如果你能在hero_selection之前让底层认为你选定了英雄就一切搞定了。顺着这个思路寻找的话，我们可以有两种方案达到：</p>
<ol>
<li>地图中拖一个  dota_custom_game_events 进去，设置里面的属性ForceSelectHero = &quot;npc_dota_hero_wisp&quot;。</li>
<li>强行设定某个英雄 GameRules:GetGameModeEntity():SetCustomGameForceHero(keys.HeroName);</li>
<li>设定自定义英雄 CreateHeroForPlayer(keys.HeroName, player)</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/08/21/mNgAHK.gif" alt="最终效果"><br>
个人比较推荐后面两种，虽然第一种也可以达到效果。经过测试发现我们在hero_selection之前就选定好了英雄，达到欺骗底层的目的了。</p>
<p>可以注意到我们还是经历了所有的STATE,只是我们在页面上没有感知而已。<br>
<img src="https://xiwan.github.io/post-images/1566377670998.png" alt=""></p>
<h3 id="展开">展开</h3>
<p>按照上面的思路，我们甚至可以做到进入游戏后再选择英雄也是可以的。重点是我们跳过了hero_selection，鼓掌散花。。。</p>
<h3 id="建议">建议</h3>
<p>首先，你必须喜欢玩moba类游戏，尤其是dota。当然不是要求你多么高的天体分，而是说你要对于大部分dota的机制都很清楚。这样理解整个dota2rpg的开发也是相当有帮助的。<br>
其次，由于valve官网的文档很难用，整个dota2rpg的入门还是没有那么容易。所以最好的方案还是看源代码配合官方文档来用，当然amhc社区对于英文不是特别好的小伙伴来说也是不错的选择。<br>
最后也是最重要的，就是要坚持，有了这一点什么事情都能做好了。</p>
<h3 id="参考">参考</h3>
<p><a href="https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Custom_Game_Setup">Custom Game Setup</a></p>
<p><a href="https://github.com/Perryvw/CustomHeroSelection">CustomHeroSelection</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dota2 文件格式]]></title>
        <id>https://xiwan.github.io/post/dota2-wen-jian-ge-shi</id>
        <link href="https://xiwan.github.io/post/dota2-wen-jian-ge-shi">
        </link>
        <updated>2019-08-13T07:18:01.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://xiwan.github.io/post-images/1565680703810.png" alt="">)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dotnetty定时器与断线重连]]></title>
        <id>https://xiwan.github.io/post/dotnetty-ding-shi-qi-yu-duan-xian-chong-lian</id>
        <link href="https://xiwan.github.io/post/dotnetty-ding-shi-qi-yu-duan-xian-chong-lian">
        </link>
        <updated>2019-08-07T11:05:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="定时器">定时器</h3>
<p>netty定时器使用比较简单，只需要作如下设置。<br>
其中，第一位为读超时时间，第二位为写超时时间，第三位为所有超时时间。如果设置为0，表示不启用。</p>
<pre><code class="language-csharp">pipeline.AddLast(&quot;IdleStateHandler&quot;, new IdleStateHandler(0, 10, 0));
</code></pre>
<p>一般来说服务器主要监听读超时事件，而客户端监听写超时事件。</p>
<p>主要通过重写 <strong>UserEventTriggered</strong> 方法来做具体的业务逻辑。</p>
<p>下面这段代码是当服务器发现丢失了三个心跳包以后直接关闭客户端的连接<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-06/5be16979352b7.png" alt=""></p>
<h3 id="断线重连">断线重连</h3>
<p>断线重连的逻辑主要是实现在客户端代码这边<strong>ChannelInactive</strong>方法</p>
<figure data-type="image" tabindex="1"><img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-06/5be169f378c3b.png" alt=""></figure>
<h4 id="测试">测试</h4>
<p>我们可以看到，每经过3个丢失的包，服务器便会主动断开客户端的连接；然后客户端知道自己被断开后，会间隔5秒尝试连接服务器，直到成功为止。</p>
<figure data-type="image" tabindex="2"><img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-06/5be16b2d3febe.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dotnettty大包与粘包]]></title>
        <id>https://xiwan.github.io/post/dotnettty-da-bao-yu-nian-bao</id>
        <link href="https://xiwan.github.io/post/dotnettty-da-bao-yu-nian-bao">
        </link>
        <updated>2019-08-07T11:04:11.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="目的">目的</h4>
<p>主要测试dotnetty在大包体，或者粘包情况下的表现</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="目的">目的</h4>
<p>主要测试dotnetty在大包体，或者粘包情况下的表现</p>
<!-- more -->
<h4 id="测试">测试</h4>
<h5 id="准备数据">准备数据</h5>
<p>代码部分：</p>
<pre><code class="language-csharp">var requestData = new RequestData();
requestData.Type = 0x0010;
for (int i = 0; i &lt; 256; i++)
{
	requestData.VarTable.Add(i.ToString());
}

var bytes = SerializationHelper.Serialize(requestData);
Console.WriteLine(ByteBufferUtil.HexDump(bytes));
Console.WriteLine(bytes.Length);
</code></pre>
<p>执行程序后内容长度为1172，算上包头和ticket部分，最终为1180长度，其中包头值为1176=0x498</p>
<pre><code>00000498000000010810120130120131120132120133120134120135120136120137120138120139120231301202313112023132120231331202313412023135120231361202313712023138120231391202323012023231120232321202323312023234120232351202323612023237120232381202323912023330120233311202333212023333120233341202333512023336120233371202333812023339120234301202343112023432120234331202343412023435120234361202343712023438120234391202353012023531120235321202353312023534120235351202353612023537120235381202353912023630120236311202363212023633120236341202363512023636120236371202363812023639120237301202373112023732120237331202373412023735120237361202373712023738120237391202383012023831120238321202383312023834120238351202383612023837120238381202383912023930120239311202393212023933120239341202393512023936120239371202393812023939120331303012033130311203313032120331303312033130341203313035120331303612033130371203313038120331303912033131301203313131120331313212033131331203313134120331313512033131361203313137120331313812033131391203313230120331323112033132321203313233120331323412033132351203313236120331323712033132381203313239120331333012033133311203313332120331333312033133341203313335120331333612033133371203313338120331333912033134301203313431120331343212033134331203313434120331343512033134361203313437120331343812033134391203313530120331353112033135321203313533120331353412033135351203313536120331353712033135381203313539120331363012033136311203313632120331363312033136341203313635120331363612033136371203313638120331363912033137301203313731120331373212033137331203313734120331373512033137361203313737120331373812033137391203313830120331383112033138321203313833120331383412033138351203313836120331383712033138381203313839120331393012033139311203313932120331393312033139341203313935120331393612033139371203313938120331393912033230301203323031120332303212033230331203323034120332303512033230361203323037120332303812033230391203323130120332313112033231321203323133120332313412033231351203323136120332313712033231381203323139120332323012033232311203323232120332323312033232341203323235120332323612033232371203323238120332323912033233301203323331120332333212033233331203323334120332333512033233361203323337120332333812033233391203323430120332343112033234321203323433120332343412033234351203323436120332343712033234381203323439120332353012033235311203323532120332353312033235341203323535
</code></pre>
<h5 id="执行测试-大包">执行测试 - 大包</h5>
<p>获取到第一个包1024<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa175c79a8.png" alt=""></p>
<p>获取到第二个包体后，可以看到buffer自动扩充到了2k，其中前1180为传输内容，符合预期<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa1bd3498c.png" alt=""></p>
<p>执行结果<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa470a413a.png" alt=""></p>
<p>由于默认的1k得不到满足，所以每条消息到来都需要重新申请2k的内存，从而更快的消耗内存导致gc<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa3fc5abd5.png" alt=""></p>
<h5 id="执行测试-粘包">执行测试 - 粘包</h5>
<p>制作一个大概1335长度(1180+155)的包体进行发送， 扩充后内存情况如下<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa9822d1c0.png" alt=""></p>
<p>读取完第一个包体后，可以看到ridx=1180<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa9b8594cb.png" alt=""></p>
<p>开始第二个包体前半部分读取,ridx=0，读取剩下的155长度数据<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaaa5d398f9.png" alt=""></p>
<p>由于tcp可以保持包的顺序，所以只要等待下一个包体到来就可以完成第二个包体的读取了。</p>
]]></content>
    </entry>
</feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiwan.github.io</id>
    <title>Keep Thinking</title>
    <updated>2019-09-18T08:05:42.623Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiwan.github.io"/>
    <link rel="self" href="https://xiwan.github.io/atom.xml"/>
    <subtitle>有美人兮心不怿</subtitle>
    <logo>https://xiwan.github.io/images/avatar.png</logo>
    <icon>https://xiwan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Keep Thinking</rights>
    <entry>
        <title type="html"><![CDATA[docker 日志处理]]></title>
        <id>https://xiwan.github.io/post/docker-ri-zhi-chu-li</id>
        <link href="https://xiwan.github.io/post/docker-ri-zhi-chu-li">
        </link>
        <updated>2019-09-18T03:59:22.000Z</updated>
        <summary type="html"><![CDATA[<p>docker 启动后有一个需求便是如何处理以及收集它产生的日志。<br>
这里的日志可以分为3类： docker的引擎日志， docker 容器日志， docker 应用日志</p>
]]></summary>
        <content type="html"><![CDATA[<p>docker 启动后有一个需求便是如何处理以及收集它产生的日志。<br>
这里的日志可以分为3类： docker的引擎日志， docker 容器日志， docker 应用日志</p>
<!-- more -->
<h3 id="docker-引擎日志">docker 引擎日志</h3>
<p>这个查找了写文章后总结如下，根据自己对应的系统去查找即可</p>
<p><strong>Ubuntu(14.04)</strong>	/var/log/upstart/docker.log<br>
<strong>Ubuntu(16.04)</strong>	journalctl -u docker.service<br>
<strong>CentOS 7/RHEL 7/Fedora</strong>	journalctl -u docker.service<br>
<strong>CoreOS</strong>	journalctl -u docker.service<br>
<strong>OpenSuSE</strong>	journalctl -u docker.service<br>
<strong>OSX</strong>	~/Library/Containers/com.docker.docker/Data/com.docker.driver.amd64-linux/log/d‌​ocker.log<br>
<strong>Debian GNU/Linux 7</strong>	/var/log/daemon.log<br>
<strong>Debian GNU/Linux 8</strong>	journalctl -u docker.service<br>
<strong>Boot2Docker</strong>	/var/log/docker.log</p>
<h3 id="docker-容器日志">docker 容器日志</h3>
<p>容器的日志 则可以通过 docker logs 命令来访问，而且可以像 tail -f 一样，使用 docker logs -f 来实时查看。如果使用 Docker Compose，则可以通过 docker-compose logs &lt;服务名&gt; 来查看。</p>
<p>如果需要查看容器日志的具体位置可以调用命令：<br>
<img src="https://xiwan.github.io/post-images/1568779631501.png" alt=""></p>
<p>可以看到这个是一个非常复杂的路径，每次看这个文件是非常不方便的。比较好的解决方案是用一个日志收集器来收集这些日志，比如利用<a href="https://tonybai.com/2016/03/25/ship-docker-container-log-with-filebeat/">filebeat</a>来收集日志，然后集中到ES中查询。不过需要一些软件安装或者配置。</p>
<p>这里我使用一个比较简单的方案， 利用docker-compose 的logs命令将对应service输出到默认的位置。这样不用担心频繁的up down导致的容器号变化。</p>
<pre><code>nohup docker-compose -f docker-compose-esk.yml logs -f kibana &gt;&gt; /data/game/logs/elk/VM_18_7_centos-kibana.log &amp;
</code></pre>
<p>当然，不同机器上的日志可以通过定时rsync命令拉取到同一台机器方便查找。</p>
<h3 id="docker应用日志">docker应用日志</h3>
<p>由于docker是无状态的，可以通过volums来实现和宿主机的互通。我们可以将docker内应用日志和数据方便地放在宿主机管理，比较简单。可以同时在宿主机上启动一个filebeat将日志发送到内部es机器即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何接入支付]]></title>
        <id>https://xiwan.github.io/post/ru-he-jie-ru-zhi-fu</id>
        <link href="https://xiwan.github.io/post/ru-he-jie-ru-zhi-fu">
        </link>
        <updated>2019-09-04T07:41:37.000Z</updated>
        <summary type="html"><![CDATA[<p>对于自定地图来说，接入支付应该是比不可少的步骤。这里主要以支付宝为例子来说明下大概流程</p>
]]></summary>
        <content type="html"><![CDATA[<p>对于自定地图来说，接入支付应该是比不可少的步骤。这里主要以支付宝为例子来说明下大概流程</p>
<!-- more -->
<h3 id="主体流程">主体流程</h3>
<p><img src="https://xiwan.github.io/post-images/1567582907291.png" alt=""></p>
<h4 id="预支付部分">预支付部分</h4>
<ol>
<li>ui界面发起向lua服务器的支付请求，同时监听支付返回事件。</li>
<li>lua服务器调用游戏服务器支付api，这里一般使用的是CreateHTTPRequestScriptVM 方法来拉起http请求。具体用法建议参考其他项目。</li>
<li>游戏服务器接入好支付sdk后，通过sdk的api拉起预支付请求（如何配置可以参考网上很多例子）。如果是java的服务器代码，就调用 AlipayTradePrecreateRequest 接口就好了。同时也可以在这里完成创建订单的操作。</li>
<li>同步等待平台预支付结果。</li>
<li>这里可以根据返回结果来做一些数据更新的操作。然后将二维码地址告知lua服务器端。</li>
<li>lua服务器获取到预支付的结果，告知ui界面展示二维码。</li>
</ol>
<h4 id="支付部分">支付部分</h4>
<ol start="7">
<li>客户扫描二维码，与平台交互支付过程。</li>
<li>支付成功后，平台返回结果给客户</li>
<li>同时，平台会异步告知交易结果给游戏服务器。游戏服务器继续完成数据更新操作。</li>
<li>似乎没啥用。</li>
</ol>
<h4 id="测试结果">测试结果</h4>
<p><img src="https://xiwan.github.io/post-images/1567582911160.png" alt=""></p>
<h4 id="注意">注意</h4>
<p>如果使用沙箱环境，要注意签名方式和对应的公钥不要弄错。就支付宝来说，需要记录两个公钥，一个是与签名方式对应的应用公钥，还有一个是基于这个公钥签发的平台公钥。</p>
<p>还有一点就是支付参数中的product_code部分需要根据签约的活动来写，不能乱写。否则会一直导致参数失败的错误。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[制作一个KV编辑器]]></title>
        <id>https://xiwan.github.io/post/zhi-zuo-yi-ge-kv-bian-ji-qi</id>
        <link href="https://xiwan.github.io/post/zhi-zuo-yi-ge-kv-bian-ji-qi">
        </link>
        <updated>2019-08-28T11:12:37.000Z</updated>
        <summary type="html"><![CDATA[<p>为了后面方便快速开发自定义英雄和技能，决定开坑先做个KV编辑器。有依赖一个第三方的库来实例化KV。</p>
]]></summary>
        <content type="html"><![CDATA[<p>为了后面方便快速开发自定义英雄和技能，决定开坑先做个KV编辑器。有依赖一个第三方的库来实例化KV。</p>
<!-- more -->
<h3 id="主要功能">主要功能</h3>
<p>[系统]<br>
1. 	设置： 一些全局参数<br>
默认打开位置（英雄，技能，物品）<br>
默认文件名字（英雄，技能，物品）<br>
导入基础数据<br>
2.  关于<br>
[编辑]<br>
[英雄]<br>
1. 	导入：读取一些已经写好的KV文件<br>
2. 	新建：创建一个新的KV<br>
[技能]<br>
1. 	导入：读取一些已经写好的KV文件<br>
2. 	新建：创建一个新的KV<br>
[物品]<br>
1. 	导入：读取一些已经写好的KV文件<br>
2. 	新建：创建一个新的KV<br>
[字典]<br>
翻译官方的一些文档</p>
<h3 id="excel">excel</h3>
<p>为了快速反应基础的变化，需要一个基于excel导入的数据库。这样可以很方便地导入导出。<br>
通用的结构：</p>
<ul>
<li>ID: 主要是标识用</li>
<li>KEY: 内置KEY名字，在输入时候会进行智能匹配 (如果是#开头，表示需要从POINT范围选取)</li>
<li>GROUP: 分组用，方便展示或者其他目的</li>
<li>VALUE: 从官方搞的一些默认值</li>
<li>COMMENT: 收集的一些说明</li>
<li>PARENT: 表明KEY之间的父子关系</li>
<li>POINT: KV的取值源头（比如DOTA_ABILITY_ATTRIBUTE#DOTAUnitAttackCapability_t  表示查看比如DOTA_ABILITY_ATTRIBUTE表的DOTAUnitAttackCapability_t的分组）</li>
</ul>
<p><img src="https://xiwan.github.io/post-images/1567421279321.png" alt=""></p>
<h3 id="截图">截图</h3>
<p><img src="https://xiwan.github.io/post-images/1566991427426.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[bot相关]]></title>
        <id>https://xiwan.github.io/post/bot-xiang-guan</id>
        <link href="https://xiwan.github.io/post/bot-xiang-guan">
        </link>
        <updated>2019-08-26T07:35:31.000Z</updated>
        <summary type="html"><![CDATA[<p>通常测试时候是需要加入一些机器人的。那么在workshop中如何加入呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>通常测试时候是需要加入一些机器人的。那么在workshop中如何加入呢？</p>
<!-- more -->
<h3 id="与bot相关的几个函数">与bot相关的几个函数</h3>
<p>int GetConnectionState(int iPlayerID)</p>
<p><code>Returns a status code indication the connection state of the player. 0 - no connection. 1 - bot connected. 2 - player connected. 3 bot/player disconnected.</code></p>
<p>bool IsControllableByAnyPlayer()</p>
<p><code>Is this unit controlled by any non-bot player?</code></p>
<p>bool IsOwnedByAnyPlayer()</p>
<p><code>Is this unit owned by any non-bot player?</code></p>
<p>void SetBotDifficulty(int nDifficulty)</p>
<p><code>Sets the bot's difficulty level (0 = passive, 1 = easy, 2 = medium, 3 = hard, 4 = unfair)</code></p>
<p><img src="https://xiwan.github.io/post-images/1566805414719.png" alt=""></p>
<p>bool AddBot(string string_1, string string_2, string string_3, bool bool_4)</p>
<p><code>Add a computer controlled bot.</code></p>
<h3 id="addbot用法">AddBot用法</h3>
<p>这里面比较重要的就是AddBot方法了。<br>
string_1 = 英雄单位的名字（默认的和自定义应该都是可以的）<br>
string_2 = 英雄位置（mid, top, bot）三条线的分路<br>
string_3 = passive/positive ？？<br>
bool_4 = 这个表示是否和玩家为队友，但可以不在一个阵营</p>
<p>如果要设置阵营，需要调用</p>
<pre><code>PlayerResource:SetCustomTeamAssignment( 0, DOTA_TEAM_GOODGUYS )
PlayerResource:SetCustomTeamAssignment( 1, DOTA_TEAM_GOODGUYS )
</code></pre>
<p><img src="https://xiwan.github.io/post-images/1566806951528.png" alt=""></p>
<p>当然，我可以枚举上面的组合来达到一下效果：同阵营队友，同阵营非队友，不同阵营队友，不同阵营非队友之类。</p>
<p>最终效果，不通阵营的队友，互相不能攻击</p>
<p><img src="https://xiwan.github.io/post-images/1566807155157.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何跳过heroselection]]></title>
        <id>https://xiwan.github.io/post/ru-he-tiao-guo-heroselection</id>
        <link href="https://xiwan.github.io/post/ru-he-tiao-guo-heroselection">
        </link>
        <updated>2019-08-20T11:57:47.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>最近研究dota2rpg时候发现一个问题：游戏流程如果使用官方的做法会比较死板。比如你必须选完队伍，然后再去选择英雄，然后再开始游戏。当然这个不是说它不好，但对于一款高度定制化的地图编辑器来说，这着实会束缚开发者的能力。很多优秀的rpg地图都可以定制整个游戏前的流程。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>最近研究dota2rpg时候发现一个问题：游戏流程如果使用官方的做法会比较死板。比如你必须选完队伍，然后再去选择英雄，然后再开始游戏。当然这个不是说它不好，但对于一款高度定制化的地图编辑器来说，这着实会束缚开发者的能力。很多优秀的rpg地图都可以定制整个游戏前的流程。</p>
<!-- more -->
<h3 id="调查">调查</h3>
<p>首先，最重要的是搞清楚已有的dota游戏流程是如何的。<br>
<img src="https://xiwan.github.io/post-images/1566368060441.png" alt=""><br>
可以看到整个流程还是比较详细的，也容易看懂。其中比较重要的就是game_setup和hero_selection了。</p>
<p>一般来说要修改game_setup界面还是比较简单的。比如：</p>
<pre><code>	&lt;Panel&gt;
		&lt;!-- Ingame HUD --&gt;
		&lt;CustomUIElement type=&quot;GameSetup&quot; layoutfile=&quot;file://{resources}/layout/custom_game/team_selection.xml&quot; /&gt;
	&lt;/Panel&gt;
</code></pre>
<p>同理我们也可以添加</p>
<pre><code>&lt;CustomUIElement type=&quot;HeroSelection&quot; layoutfile=&quot;file://{resources}/layout/custom_game/pick_hero.xml&quot; /&gt;
</code></pre>
<p>这样来达到自定义界面的效果。<br>
当我尝试出来效果一般。首先按照这个思路我们还是必须严格按照流程来进行界面设置。也就是必须设置完了队伍再去选择英雄之类。那如果游戏的设定不希望是这个流程呢？其次感觉要覆盖掉原来的英雄选择界面比较麻烦。我摸索出来的思路就是一个覆盖而已，效果如下：</p>
<p><img src="https://xiwan.github.io/post-images/1566369563083.png" alt=""></p>
<h3 id="跳出盒子">跳出盒子</h3>
<p>有没有可能我在game_setup里面就直接做完了所有的事情呢。这样的话我们就不必完全按照预设的流程。</p>
<h4 id="准备工作">准备工作：</h4>
<p>我们需要让game_setup不往hero_selection走。那么需要这么设置：</p>
<pre><code>function COverthrowGameMode:OnGameRulesStateChange()
	local nNewState = GameRules:State_Get()

	-- Disable auto launch when entering custom game setup, it can be
	-- re-enabled at any point later while still in custom game setup
	if nNewState == DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP then
		GameRules:EnableCustomGameSetupAutoLaunch( false )
	end
end
</code></pre>
<p>这样就不会发生跳转了。</p>
<p>接下来的问题是：我们可以自己做一个英雄界面(或者其他准备界面)，但怎么跳过默认的hero_selection？官网并没提供可以跳过某个步骤的接口。就是说按照dota2底层实现它是必须严格按照上面的顺序来做的。</p>
<p>经过摸索，其实道理很简单。为什么默认机制是会强行你进入hero_selection?那是因为你没有英雄。如果你能在hero_selection之前让底层认为你选定了英雄就一切搞定了。顺着这个思路寻找的话，我们可以有两种方案达到：</p>
<ol>
<li>地图中拖一个  dota_custom_game_events 进去，设置里面的属性ForceSelectHero = &quot;npc_dota_hero_wisp&quot;。</li>
<li>强行设定某个英雄 GameRules:GetGameModeEntity():SetCustomGameForceHero(keys.HeroName);</li>
<li>设定自定义英雄 CreateHeroForPlayer(keys.HeroName, player)</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/08/21/mNgAHK.gif" alt="最终效果"><br>
个人比较推荐后面两种，虽然第一种也可以达到效果。经过测试发现我们在hero_selection之前就选定好了英雄，达到欺骗底层的目的了。</p>
<p>可以注意到我们还是经历了所有的STATE,只是我们在页面上没有感知而已。<br>
<img src="https://xiwan.github.io/post-images/1566377670998.png" alt=""></p>
<h3 id="展开">展开</h3>
<p>按照上面的思路，我们甚至可以做到进入游戏后再选择英雄也是可以的。重点是我们跳过了hero_selection，鼓掌散花。。。</p>
<h3 id="建议">建议</h3>
<p>首先，你必须喜欢玩moba类游戏，尤其是dota。当然不是要求你多么高的天体分，而是说你要对于大部分dota的机制都很清楚。这样理解整个dota2rpg的开发也是相当有帮助的。<br>
其次，由于valve官网的文档很难用，整个dota2rpg的入门还是没有那么容易。所以最好的方案还是看源代码配合官方文档来用，当然amhc社区对于英文不是特别好的小伙伴来说也是不错的选择。<br>
最后也是最重要的，就是要坚持，有了这一点什么事情都能做好了。</p>
<h3 id="参考">参考</h3>
<p><a href="https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Custom_Game_Setup">Custom Game Setup</a></p>
<p><a href="https://github.com/Perryvw/CustomHeroSelection">CustomHeroSelection</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dota2 文件格式]]></title>
        <id>https://xiwan.github.io/post/dota2-wen-jian-ge-shi</id>
        <link href="https://xiwan.github.io/post/dota2-wen-jian-ge-shi">
        </link>
        <updated>2019-08-13T07:18:01.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://xiwan.github.io/post-images/1565680703810.png" alt="">)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dotnetty定时器与断线重连]]></title>
        <id>https://xiwan.github.io/post/dotnetty-ding-shi-qi-yu-duan-xian-chong-lian</id>
        <link href="https://xiwan.github.io/post/dotnetty-ding-shi-qi-yu-duan-xian-chong-lian">
        </link>
        <updated>2019-08-07T11:05:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="定时器">定时器</h3>
<p>netty定时器使用比较简单，只需要作如下设置。<br>
其中，第一位为读超时时间，第二位为写超时时间，第三位为所有超时时间。如果设置为0，表示不启用。</p>
<pre><code class="language-csharp">pipeline.AddLast(&quot;IdleStateHandler&quot;, new IdleStateHandler(0, 10, 0));
</code></pre>
<p>一般来说服务器主要监听读超时事件，而客户端监听写超时事件。</p>
<p>主要通过重写 <strong>UserEventTriggered</strong> 方法来做具体的业务逻辑。</p>
<p>下面这段代码是当服务器发现丢失了三个心跳包以后直接关闭客户端的连接<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-06/5be16979352b7.png" alt=""></p>
<h3 id="断线重连">断线重连</h3>
<p>断线重连的逻辑主要是实现在客户端代码这边<strong>ChannelInactive</strong>方法</p>
<p><img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-06/5be169f378c3b.png" alt=""></p>
<h4 id="测试">测试</h4>
<p>我们可以看到，每经过3个丢失的包，服务器便会主动断开客户端的连接；然后客户端知道自己被断开后，会间隔5秒尝试连接服务器，直到成功为止。</p>
<p><img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-06/5be16b2d3febe.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dotnettty大包与粘包]]></title>
        <id>https://xiwan.github.io/post/dotnettty-da-bao-yu-nian-bao</id>
        <link href="https://xiwan.github.io/post/dotnettty-da-bao-yu-nian-bao">
        </link>
        <updated>2019-08-07T11:04:11.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="目的">目的</h4>
<p>主要测试dotnetty在大包体，或者粘包情况下的表现</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="目的">目的</h4>
<p>主要测试dotnetty在大包体，或者粘包情况下的表现</p>
<!-- more -->
<h4 id="测试">测试</h4>
<h5 id="准备数据">准备数据</h5>
<p>代码部分：</p>
<pre><code class="language-csharp">var requestData = new RequestData();
requestData.Type = 0x0010;
for (int i = 0; i &lt; 256; i++)
{
	requestData.VarTable.Add(i.ToString());
}

var bytes = SerializationHelper.Serialize(requestData);
Console.WriteLine(ByteBufferUtil.HexDump(bytes));
Console.WriteLine(bytes.Length);
</code></pre>
<p>执行程序后内容长度为1172，算上包头和ticket部分，最终为1180长度，其中包头值为1176=0x498</p>
<pre><code>00000498000000010810120130120131120132120133120134120135120136120137120138120139120231301202313112023132120231331202313412023135120231361202313712023138120231391202323012023231120232321202323312023234120232351202323612023237120232381202323912023330120233311202333212023333120233341202333512023336120233371202333812023339120234301202343112023432120234331202343412023435120234361202343712023438120234391202353012023531120235321202353312023534120235351202353612023537120235381202353912023630120236311202363212023633120236341202363512023636120236371202363812023639120237301202373112023732120237331202373412023735120237361202373712023738120237391202383012023831120238321202383312023834120238351202383612023837120238381202383912023930120239311202393212023933120239341202393512023936120239371202393812023939120331303012033130311203313032120331303312033130341203313035120331303612033130371203313038120331303912033131301203313131120331313212033131331203313134120331313512033131361203313137120331313812033131391203313230120331323112033132321203313233120331323412033132351203313236120331323712033132381203313239120331333012033133311203313332120331333312033133341203313335120331333612033133371203313338120331333912033134301203313431120331343212033134331203313434120331343512033134361203313437120331343812033134391203313530120331353112033135321203313533120331353412033135351203313536120331353712033135381203313539120331363012033136311203313632120331363312033136341203313635120331363612033136371203313638120331363912033137301203313731120331373212033137331203313734120331373512033137361203313737120331373812033137391203313830120331383112033138321203313833120331383412033138351203313836120331383712033138381203313839120331393012033139311203313932120331393312033139341203313935120331393612033139371203313938120331393912033230301203323031120332303212033230331203323034120332303512033230361203323037120332303812033230391203323130120332313112033231321203323133120332313412033231351203323136120332313712033231381203323139120332323012033232311203323232120332323312033232341203323235120332323612033232371203323238120332323912033233301203323331120332333212033233331203323334120332333512033233361203323337120332333812033233391203323430120332343112033234321203323433120332343412033234351203323436120332343712033234381203323439120332353012033235311203323532120332353312033235341203323535
</code></pre>
<h5 id="执行测试-大包">执行测试 - 大包</h5>
<p>获取到第一个包1024<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa175c79a8.png" alt=""></p>
<p>获取到第二个包体后，可以看到buffer自动扩充到了2k，其中前1180为传输内容，符合预期<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa1bd3498c.png" alt=""></p>
<p>执行结果<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa470a413a.png" alt=""></p>
<p>由于默认的1k得不到满足，所以每条消息到来都需要重新申请2k的内存，从而更快的消耗内存导致gc<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa3fc5abd5.png" alt=""></p>
<h5 id="执行测试-粘包">执行测试 - 粘包</h5>
<p>制作一个大概1335长度(1180+155)的包体进行发送， 扩充后内存情况如下<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa9822d1c0.png" alt=""></p>
<p>读取完第一个包体后，可以看到ridx=1180<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa9b8594cb.png" alt=""></p>
<p>开始第二个包体前半部分读取,ridx=0，读取剩下的155长度数据<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaaa5d398f9.png" alt=""></p>
<p>由于tcp可以保持包的顺序，所以只要等待下一个包体到来就可以完成第二个包体的读取了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[serilog vs log4net]]></title>
        <id>https://xiwan.github.io/post/serilog-vs-log4net</id>
        <link href="https://xiwan.github.io/post/serilog-vs-log4net">
        </link>
        <updated>2019-08-07T10:58:59.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="目的">目的</h3>
<p>通过测试数值来比较两个库的优劣</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="目的">目的</h3>
<p>通过测试数值来比较两个库的优劣</p>
<!-- more -->
<h3 id="场景">场景</h3>
<h4 id="login-接口带业务">Login 接口（带业务）</h4>
<p>参数： 线程250， 时间20分钟， 队列长度：5w, 队列读取间隔： 1s， 不做合并写<br>
数据：<br>
0000001c00000003088080b807120464646464120012054465627567</p>
<p>log4net:<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-19/5bf26878b66af.png" alt=""></p>
<p>serilog:<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-19/5bf268d599233.png" alt=""></p>
<p>相同参数：队列积压：4k-5k区间， cpu: 300%, mem: 4% 都是差不多的。<br>
差异参数：偏差值: serilog(8.64) &lt; log4net(13.28), 吞吐量serilog也优秀5%左右。</p>
<h4 id="hearbeat-接口">hearbeat 接口</h4>
<p>参数： 线程3000， 时间20分钟， 队列长度：5w, 队列读取间隔： 1s， 不做合并写<br>
数据：<br>
000000130000000108ffffff07120130120131</p>
<p>log4net:<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-19/5bf2759097410.png" alt=""></p>
<p>serilog:<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-19/5bf26d2ba7bdb.png" alt=""></p>
<p>相同参数：cpu: 300%； mem: 4%；都是差不多的。<br>
差异参数：队列积压：serilog(25-30k), log4net(40k+)；；吞吐量:serilog(2.6w)， log4net(1.5w)；偏差值：serilog(33.42), log4net(17.78)</p>
<h3 id="观察">观察</h3>
<p>在低压力（上千并发）情况下： log4net和serilog的差距不是很明显。</p>
<p>在高压力（上万并发）情况下：这里log4net由于写的并发不高，导致它的吞吐也是一个慢慢爬坡的过程，并且队列积压严重（超过80%）；相反serilog对于写的优秀支持，它可以很快的到达吞吐并发，队列积压只有log4net的一半左右。</p>
<h3 id="延申">延申</h3>
<p>再日志放大10倍的压力下，serilog的效率和log4net差不多，都降到了1万每秒，并且有10%的错误率。原因是这个时候，大家都已经把队列撑爆了，这个时候的瓶颈就是队列了。那么通过调整参数得出下表</p>
<table>
<thead>
<tr>
<th>serilog</th>
<th>tps</th>
<th>错误率</th>
<th>队列积压 (5w)</th>
<th>预估能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>10条</td>
<td>1.1w/s</td>
<td>10%</td>
<td>5w</td>
<td>-</td>
</tr>
<tr>
<td>3条</td>
<td>2.1w/s</td>
<td>0.6%</td>
<td>5w</td>
<td>-</td>
</tr>
<tr>
<td>2条</td>
<td>2.5w/s</td>
<td>0.01%</td>
<td>4.1w</td>
<td>5w/s</td>
</tr>
<tr>
<td>1条</td>
<td>2.5w/s</td>
<td>0%</td>
<td>2.5w</td>
<td>2.3w/s</td>
</tr>
</tbody>
</table>
<p>从这里看出，再队列预设5w长度情况下，serilog可以到达5w/s(但并不是它的峰值)。这么看来后续需要加长队列继续测试：</p>
<p>10w队列</p>
<table>
<thead>
<tr>
<th>serilog</th>
<th>tps</th>
<th>错误率</th>
<th>队列积压</th>
<th>预估能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>10条</td>
<td>1.3w/s</td>
<td>10%</td>
<td>10w</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>20w队列</p>
<table>
<thead>
<tr>
<th>serilog</th>
<th>tps</th>
<th>错误率</th>
<th>队列积压</th>
<th>预估能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>10条</td>
<td>1.6w/s</td>
<td>1%</td>
<td>16w</td>
<td>15w/s</td>
</tr>
</tbody>
</table>
<p>100w队列</p>
<table>
<thead>
<tr>
<th>serilog</th>
<th>tps</th>
<th>错误率</th>
<th>队列积压</th>
<th>预估能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>10条</td>
<td>1.8w/s</td>
<td>0.03%</td>
<td>2w</td>
<td>18w/s</td>
</tr>
</tbody>
</table>
<p>所以可以预估在内存充足的情况下serilog的写入能力为15w-18w之间</p>
<p>网上另一位测试者的结果也侧面证明了我的结果<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-20/5bf3b95b2663c.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于docker搭建centos模板环境]]></title>
        <id>https://xiwan.github.io/post/JMW1yxHv1</id>
        <link href="https://xiwan.github.io/post/JMW1yxHv1">
        </link>
        <updated>2019-08-07T08:29:00.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>我们已经基于标准shell建立了一整套服务器环境搭建体系，在平常运维中，其实只要记住那一步执行哪个shell脚本就好了。但是执行了一段时间后，还是觉得不够灵活。想象如下场景：有一天你刚回收完一套环境，这个时候来了个需求需要尽快搭建一套独立环境之类。这个时候需要重新执行一次所有的脚本，时间比较慢，并且数据可靠性也无法保证。这个时候我想到了docker，虽然我们有在测试环境部分使用它的功能，但并没有真正拿他做到<strong>开箱即用</strong></p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>我们已经基于标准shell建立了一整套服务器环境搭建体系，在平常运维中，其实只要记住那一步执行哪个shell脚本就好了。但是执行了一段时间后，还是觉得不够灵活。想象如下场景：有一天你刚回收完一套环境，这个时候来了个需求需要尽快搭建一套独立环境之类。这个时候需要重新执行一次所有的脚本，时间比较慢，并且数据可靠性也无法保证。这个时候我想到了docker，虽然我们有在测试环境部分使用它的功能，但并没有真正拿他做到<strong>开箱即用</strong></p>
<!-- more -->
<p>以下的流程只是一个测试例子，真实环境需要对不同环境来写不同的镜像。由于我比较懒，所以暂且把所有服务都放在一个镜像里面。</p>
<h1 id="基本流程">基本流程</h1>
<ol>
<li>基于centos 镜像</li>
<li>准备环境的镜像</li>
<li>导出镜像/容器</li>
</ol>
<h1 id="基于centos镜像">基于centos镜像</h1>
<p>这个比较简单，可以到docker hub上面找centos:7， 然后编写dockerfile</p>
<pre><code>FROM centos:7 AS s1
ENV container docker
RUN (cd /lib/systemd/system/sysinit.target.wants/; for i in *; do [ $i == \
systemd-tmpfiles-setup.service ] || rm -f $i; done); \
rm -f /lib/systemd/system/multi-user.target.wants/*;\
rm -f /etc/systemd/system/*.wants/*;\
rm -f /lib/systemd/system/local-fs.target.wants/*; \
rm -f /lib/systemd/system/sockets.target.wants/*udev*; \
rm -f /lib/systemd/system/sockets.target.wants/*initctl*; \
rm -f /lib/systemd/system/basic.target.wants/*;\
rm -f /lib/systemd/system/anaconda.target.wants/*;
VOLUME [ &quot;/data/game&quot; ]
CMD [&quot;/usr/sbin/init&quot;]
</code></pre>
<p>这里主要设置的就是根据不同环境而挂载的VOLUME。目的是为了让镜像无状态化，中间的数据都需要存储到宿主机。</p>
<h1 id="制作环境准备的镜像">制作环境准备的镜像</h1>
<p>上一步只是完成了一些最基本的设置，接下来需要按照应用或者游戏需要应用到的服务来安装和启动。</p>
<ol>
<li>安装网络和设置yum源（通常已经有了）</li>
<li>更新yum</li>
<li>安装软件</li>
<li>配置端口</li>
</ol>
<p>s2依赖于s1</p>
<pre><code>FROM allinone:s1 AS s2
USER root
RUN yum -y install net-tools \
  &amp;&amp; yum -y install wget \
  &amp;&amp; yum remove epel-release \
  &amp;&amp; wget https://mirrors.ustc.edu.cn/epel//7/x86_64/Packages/e/epel-release-7-11.noarch.rpm \
  &amp;&amp; rpm -ivh epel-release-7-11.noarch.rpm \
  &amp;&amp; yum clean all \
  &amp;&amp; yum makecache \
  # update热更新
  &amp;&amp; yum provides '*/applydeltarpm' \ 
  &amp;&amp; yum install deltarpm -y \
  &amp;&amp; yum -y update \
  # 安装sshpass
  &amp;&amp; yum -y install sshpass \
  # 安装subversion
  &amp;&amp; yum -y install subversion \
  # 安装xinetd
  &amp;&amp; yum -y install xinetd \
  #&amp;&amp; yum -y install ntpd \
  &amp;&amp; yum -y install rsync \
  &amp;&amp; yum install -y unzip zip \
  &amp;&amp; yum -y install crontabs

CMD [&quot;/usr/sbin/init&quot;]
</code></pre>
<p>s3又依赖于s2</p>
<pre><code>FROM allinone:s2 AS s3
USER root
RUN yum -y install nginx \
  # 安装supervisor
  &amp;&amp; yum -y install python-setuptools \
  &amp;&amp; easy_install supervisor \
  # 安装 redis
  &amp;&amp; yum -y install redis \
  # 安装 mysql
  &amp;&amp; wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm \
  &amp;&amp; rpm -ivh mysql-community-release-el7-5.noarch.rpm \
  &amp;&amp; yum -y install mysql-community-server \
  &amp;&amp; yum -y install mysql-community-client \
  # 安装 dotnet
  &amp;&amp; rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm \
  &amp;&amp; yum update \
  &amp;&amp; yum -y install aspnetcore-runtime-2.1 \
  &amp;&amp; yum -y install dotnet-sdk-2.1

EXPOSE 80 3306 6379 7000 8001 8009 8010 8011 8012 8013
CMD [&quot;/usr/sbin/init&quot;]
</code></pre>
<p>这里要注意的是，<strong>我们不能在此步骤种进行任何的service或者systemctl之类后台任务的命令</strong>，否则会导致镜像建立的失败。</p>
<p>主要原因是：Docker的设计理念是在容器里面不运行后台服务，容器本身就是宿主机上的一个独立的主进程，也可以间接的理解为就是容器里运行服务的应用进程。一个容器的生命周期是围绕这个主进程存在的，所以正确的使用容器方法是将里面的服务运行在前台。</p>
<p>systemd维护系统服务程序，它需要特权去会访问Linux内核。而容器并不是一个完整的操作系统，只有一个文件系统，而且默认启动只是普通用户这样的权限访问Linux内核，也就是没有特权，所以自然就用不了！</p>
<p>当然我们可以稍后在运行容器时候使用<strong>特权模式</strong>就可以绕开这个问题了。</p>
<p>当我们运行上述dockerfile后，检查镜像列表<br>
<img src="https://xiwan.github.io/post-images/1565169711513.png" alt=""></p>
<p><em>centos:7是最基础的，<br>
然后基于它我们构建了allinone:s1, 由于它并没有实质性的安装任何软件，所以看到大小并没有变化，这里我们可以只是作一些最基础的设置<br>
接下来看allinone:s2，可以看到大小有2G多，这里主要是安装应用需要的软件。在实际运用种可以根据服务器的角色不同而安装不同的软件。</em></p>
<p><em>这里，我们可以把上述所有的dockerfile合并成一个，利用target参数来分步执行。</em></p>
<h1 id="导出镜像容器">导出镜像/容器</h1>
<p>先找到容器 id导出成tar/zip都可以</p>
<pre><code>docker export df5138d2e73d &gt; test.tar
</code></pre>
<p>然后就可以把这个文件上传到公共服务器，其他服务器只需要去拉取这个镜像就可以了</p>
<pre><code>cat test.tar | docker import - allinone:s3
</code></pre>
<p>正如前面描述，由于在镜像生成中无法进行systemctl或者service的后台工作，在实际运用中导出容器比较方便。我们可以在容器中将所有的服务都挂载后台起来后，然后再导出。这样才能做到真正的开箱即用。</p>
<p>不过开箱有一个要注意的地方，需要在run/create 容器命令最后加上对应的CMD(也就是启动命令，而不是简单的bash)<br>
比如：</p>
<pre><code>docker create -v /data/docker/kaki:/data/docker/kaki --privileged=true --name=kakigameserver -p 80:80 -i allinone:s3 /usr/sbin/init
</code></pre>
<h1 id="如何制作和配置无关的容器">如何制作和配置无关的容器</h1>
<p>由于我们在编排docker时候，不大可能为了每套测试或者生产环境设置一个对应的容器。比较直接的做法是上线后替换配置文件的内容。这个操作用脚本还是可以做到的。但不停的替换文件内容，其实是一个比较容易出错的操作。</p>
<p>个人认为比较好的一种做法：启动文件固定成一个软连接的路径，或者可以称它为代理。到了不同环境利用脚本替换代理的指向即可。</p>
<h1 id="引入docker-compose">引入docker-compose</h1>
<p>可以引入docker-compose这种方案，来优化容器的管理和部属。这样就避免了繁琐的create和start。编排好yml文件后，直接up就可以启动整个容器了。一个例子：</p>
<pre><code>version: '2'
services:
  all-in-one:
    image: &quot;allinone:s3&quot;
    build: ./
    environment:
      - JAVA_OPTS=-Dorg.apache.commons.jelly.tags.fmt.timeZone=Asia/Shanghai 
    ports:
      - 13306:3306
			- 18001:8001
    container_name: docker-test
    privileged: true
    restart: always
    volumes:
        - /data/game:/data/game
    ulimits:
      nproc: 65535
      nofile:
        soft: 20000
        hard: 40000
</code></pre>
<h1 id="参考">参考</h1>
<p><a href="https://yeasy.gitbooks.io/docker_practice/content/compose/commands.html#build">dockerfile</a></p>
]]></content>
    </entry>
</feed>
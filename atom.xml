<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiwan.github.io</id>
    <title>Keep Thinking</title>
    <updated>2019-08-28T11:28:00.350Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiwan.github.io"/>
    <link rel="self" href="https://xiwan.github.io/atom.xml"/>
    <subtitle>有美人兮心不怿</subtitle>
    <logo>https://xiwan.github.io/images/avatar.png</logo>
    <icon>https://xiwan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Keep Thinking</rights>
    <entry>
        <title type="html"><![CDATA[制作一个KV编辑器]]></title>
        <id>https://xiwan.github.io/post/zhi-zuo-yi-ge-kv-bian-ji-qi</id>
        <link href="https://xiwan.github.io/post/zhi-zuo-yi-ge-kv-bian-ji-qi">
        </link>
        <updated>2019-08-28T11:12:37.000Z</updated>
        <summary type="html"><![CDATA[<p>为了后面方便快速开发自定义英雄和技能，决定开坑先做个KV编辑器。有依赖一个第三方的库来实例化KV。</p>
]]></summary>
        <content type="html"><![CDATA[<p>为了后面方便快速开发自定义英雄和技能，决定开坑先做个KV编辑器。有依赖一个第三方的库来实例化KV。</p>
<!-- more -->
<h3 id="主要功能">主要功能</h3>
<p>[系统]<br>
1. 	设置： 一些全局参数<br>
默认打开位置（英雄，技能，物品）<br>
默认文件名字（英雄，技能，物品）<br>
导入基础数据<br>
2.  关于<br>
[编辑]<br>
[英雄]<br>
1. 	导入：读取一些已经写好的KV文件<br>
2. 	新建：创建一个新的KV<br>
[技能]<br>
1. 	导入：读取一些已经写好的KV文件<br>
2. 	新建：创建一个新的KV<br>
[物品]<br>
1. 	导入：读取一些已经写好的KV文件<br>
2. 	新建：创建一个新的KV<br>
[字典]<br>
翻译官方的一些文档</p>
<h3 id="截图">截图</h3>
<p><img src="https://xiwan.github.io/post-images/1566991427426.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dota1V5]]></title>
        <id>https://xiwan.github.io/post/dota1v5</id>
        <link href="https://xiwan.github.io/post/dota1v5">
        </link>
        <updated>2019-08-26T08:29:39.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="intro">Intro</h2>
<p>&quot;Dead by Daylight&quot; dota2 mod: 2 teams Master and Slave. Master have only one player, but Slave have 5.<br>
Every match have 10-mins time for the Slave team eascaping from the pursuit of Master.</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="intro">Intro</h2>
<p>&quot;Dead by Daylight&quot; dota2 mod: 2 teams Master and Slave. Master have only one player, but Slave have 5.<br>
Every match have 10-mins time for the Slave team eascaping from the pursuit of Master.</p>
<!-- more -->
<h2 id="slave-team">Slave Team</h2>
<h3 id="nurse">Nurse</h3>
<h4 id="borned-skills">borned skills</h4>
<ol>
<li>Bandage:<br>
small radius, continous spell, heal some amout of health<br>
target: unit</li>
<li>Injection:<br>
small radius, quick spell, cost some unit's health for high speed<br>
target: unit</li>
</ol>
<h3 id="solider">Solider</h3>
<h4 id="borned-skill">borned skill:</h4>
<ol>
<li>Shield Hammer: Stun target 2s</li>
<li></li>
</ol>
<h3 id="engineer">Engineer</h3>
<h4 id="borned-skill-2">borned skill:</h4>
<ol>
<li>Amend：small radius, fix-up trap, light, engin and etc.</li>
<li>Build: small radius, Trap, light</li>
</ol>
<h3 id="burglar">Burglar</h3>
<h4 id="borned-skill-3">borned skill:</h4>
<ol>
<li>Agility: very fast</li>
<li>Swipe: steal equips from master house</li>
</ol>
<h2 id="master-team">Master Team</h2>
<h3 id="butcher">Butcher</h3>
<h4 id="borned-skill-4">borned skill:</h4>
<ol>
<li>Hook：pull  target back</li>
<li>Hang:</li>
</ol>
<h3 id="warden">warden</h3>
<h4 id="borned-skill-5">borned skill:</h4>
<ol>
<li>Horify: Slow target movement 50%</li>
<li>Hound: Command a hound attacking unit</li>
<li>Prision:</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[bot相关]]></title>
        <id>https://xiwan.github.io/post/bot-xiang-guan</id>
        <link href="https://xiwan.github.io/post/bot-xiang-guan">
        </link>
        <updated>2019-08-26T07:35:31.000Z</updated>
        <summary type="html"><![CDATA[<p>通常测试时候是需要加入一些机器人的。那么在workshop中如何加入呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>通常测试时候是需要加入一些机器人的。那么在workshop中如何加入呢？</p>
<!-- more -->
<h3 id="与bot相关的几个函数">与bot相关的几个函数</h3>
<p>int GetConnectionState(int iPlayerID)</p>
<p><code>Returns a status code indication the connection state of the player. 0 - no connection. 1 - bot connected. 2 - player connected. 3 bot/player disconnected.</code></p>
<p>bool IsControllableByAnyPlayer()</p>
<p><code>Is this unit controlled by any non-bot player?</code></p>
<p>bool IsOwnedByAnyPlayer()</p>
<p><code>Is this unit owned by any non-bot player?</code></p>
<p>void SetBotDifficulty(int nDifficulty)</p>
<p><code>Sets the bot's difficulty level (0 = passive, 1 = easy, 2 = medium, 3 = hard, 4 = unfair)</code></p>
<p><img src="https://xiwan.github.io/post-images/1566805414719.png" alt=""></p>
<p>bool AddBot(string string_1, string string_2, string string_3, bool bool_4)</p>
<p><code>Add a computer controlled bot.</code></p>
<h3 id="addbot用法">AddBot用法</h3>
<p>这里面比较重要的就是AddBot方法了。<br>
string_1 = 英雄单位的名字（默认的和自定义应该都是可以的）<br>
string_2 = 英雄位置（mid, top, bot）三条线的分路<br>
string_3 = passive/positive ？？<br>
bool_4 = 这个表示是否和玩家为队友，但可以不在一个阵营</p>
<p>如果要设置阵营，需要调用</p>
<pre><code>PlayerResource:SetCustomTeamAssignment( 0, DOTA_TEAM_GOODGUYS )
PlayerResource:SetCustomTeamAssignment( 1, DOTA_TEAM_GOODGUYS )
</code></pre>
<p><img src="https://xiwan.github.io/post-images/1566806951528.png" alt=""></p>
<p>当然，我可以枚举上面的组合来达到一下效果：同阵营队友，同阵营非队友，不同阵营队友，不同阵营非队友之类。</p>
<p>最终效果，不通阵营的队友，互相不能攻击</p>
<p><img src="https://xiwan.github.io/post-images/1566807155157.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何跳过heroselection]]></title>
        <id>https://xiwan.github.io/post/ru-he-tiao-guo-heroselection</id>
        <link href="https://xiwan.github.io/post/ru-he-tiao-guo-heroselection">
        </link>
        <updated>2019-08-20T11:57:47.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>最近研究dota2rpg时候发现一个问题：游戏流程如果使用官方的做法会比较死板。比如你必须选完队伍，然后再去选择英雄，然后再开始游戏。当然这个不是说它不好，但对于一款高度定制化的地图编辑器来说，这着实会束缚开发者的能力。很多优秀的rpg地图都可以定制整个游戏前的流程。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="背景">背景</h3>
<p>最近研究dota2rpg时候发现一个问题：游戏流程如果使用官方的做法会比较死板。比如你必须选完队伍，然后再去选择英雄，然后再开始游戏。当然这个不是说它不好，但对于一款高度定制化的地图编辑器来说，这着实会束缚开发者的能力。很多优秀的rpg地图都可以定制整个游戏前的流程。</p>
<!-- more -->
<h3 id="调查">调查</h3>
<p>首先，最重要的是搞清楚已有的dota游戏流程是如何的。<br>
<img src="https://xiwan.github.io/post-images/1566368060441.png" alt=""><br>
可以看到整个流程还是比较详细的，也容易看懂。其中比较重要的就是game_setup和hero_selection了。</p>
<p>一般来说要修改game_setup界面还是比较简单的。比如：</p>
<pre><code>	&lt;Panel&gt;
		&lt;!-- Ingame HUD --&gt;
		&lt;CustomUIElement type=&quot;GameSetup&quot; layoutfile=&quot;file://{resources}/layout/custom_game/team_selection.xml&quot; /&gt;
	&lt;/Panel&gt;
</code></pre>
<p>同理我们也可以添加</p>
<pre><code>&lt;CustomUIElement type=&quot;HeroSelection&quot; layoutfile=&quot;file://{resources}/layout/custom_game/pick_hero.xml&quot; /&gt;
</code></pre>
<p>这样来达到自定义界面的效果。<br>
当我尝试出来效果一般。首先按照这个思路我们还是必须严格按照流程来进行界面设置。也就是必须设置完了队伍再去选择英雄之类。那如果游戏的设定不希望是这个流程呢？其次感觉要覆盖掉原来的英雄选择界面比较麻烦。我摸索出来的思路就是一个覆盖而已，效果如下：</p>
<p><img src="https://xiwan.github.io/post-images/1566369563083.png" alt=""></p>
<h3 id="跳出盒子">跳出盒子</h3>
<p>有没有可能我在game_setup里面就直接做完了所有的事情呢。这样的话我们就不必完全按照预设的流程。</p>
<h4 id="准备工作">准备工作：</h4>
<p>我们需要让game_setup不往hero_selection走。那么需要这么设置：</p>
<pre><code>function COverthrowGameMode:OnGameRulesStateChange()
	local nNewState = GameRules:State_Get()

	-- Disable auto launch when entering custom game setup, it can be
	-- re-enabled at any point later while still in custom game setup
	if nNewState == DOTA_GAMERULES_STATE_CUSTOM_GAME_SETUP then
		GameRules:EnableCustomGameSetupAutoLaunch( false )
	end
end
</code></pre>
<p>这样就不会发生跳转了。</p>
<p>接下来的问题是：我们可以自己做一个英雄界面(或者其他准备界面)，但怎么跳过默认的hero_selection？官网并没提供可以跳过某个步骤的接口。就是说按照dota2底层实现它是必须严格按照上面的顺序来做的。</p>
<p>经过摸索，其实道理很简单。为什么默认机制是会强行你进入hero_selection?那是因为你没有英雄。如果你能在hero_selection之前让底层认为你选定了英雄就一切搞定了。顺着这个思路寻找的话，我们可以有两种方案达到：</p>
<ol>
<li>地图中拖一个  dota_custom_game_events 进去，设置里面的属性ForceSelectHero = &quot;npc_dota_hero_wisp&quot;。</li>
<li>强行设定某个英雄 GameRules:GetGameModeEntity():SetCustomGameForceHero(keys.HeroName);</li>
<li>设定自定义英雄 CreateHeroForPlayer(keys.HeroName, player)</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/08/21/mNgAHK.gif" alt="最终效果"><br>
个人比较推荐后面两种，虽然第一种也可以达到效果。经过测试发现我们在hero_selection之前就选定好了英雄，达到欺骗底层的目的了。</p>
<p>可以注意到我们还是经历了所有的STATE,只是我们在页面上没有感知而已。<br>
<img src="https://xiwan.github.io/post-images/1566377670998.png" alt=""></p>
<h3 id="展开">展开</h3>
<p>按照上面的思路，我们甚至可以做到进入游戏后再选择英雄也是可以的。重点是我们跳过了hero_selection，鼓掌散花。。。</p>
<h3 id="建议">建议</h3>
<p>首先，你必须喜欢玩moba类游戏，尤其是dota。当然不是要求你多么高的天体分，而是说你要对于大部分dota的机制都很清楚。这样理解整个dota2rpg的开发也是相当有帮助的。<br>
其次，由于valve官网的文档很难用，整个dota2rpg的入门还是没有那么容易。所以最好的方案还是看源代码配合官方文档来用，当然amhc社区对于英文不是特别好的小伙伴来说也是不错的选择。<br>
最后也是最重要的，就是要坚持，有了这一点什么事情都能做好了。</p>
<h3 id="参考">参考</h3>
<p><a href="https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Custom_Game_Setup">Custom Game Setup</a></p>
<p><a href="https://github.com/Perryvw/CustomHeroSelection">CustomHeroSelection</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dota2 文件格式]]></title>
        <id>https://xiwan.github.io/post/dota2-wen-jian-ge-shi</id>
        <link href="https://xiwan.github.io/post/dota2-wen-jian-ge-shi">
        </link>
        <updated>2019-08-13T07:18:01.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://xiwan.github.io/post-images/1565680703810.png" alt="">)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dotnetty定时器与断线重连]]></title>
        <id>https://xiwan.github.io/post/dotnetty-ding-shi-qi-yu-duan-xian-chong-lian</id>
        <link href="https://xiwan.github.io/post/dotnetty-ding-shi-qi-yu-duan-xian-chong-lian">
        </link>
        <updated>2019-08-07T11:05:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="定时器">定时器</h3>
<p>netty定时器使用比较简单，只需要作如下设置。<br>
其中，第一位为读超时时间，第二位为写超时时间，第三位为所有超时时间。如果设置为0，表示不启用。</p>
<pre><code class="language-csharp">pipeline.AddLast(&quot;IdleStateHandler&quot;, new IdleStateHandler(0, 10, 0));
</code></pre>
<p>一般来说服务器主要监听读超时事件，而客户端监听写超时事件。</p>
<p>主要通过重写 <strong>UserEventTriggered</strong> 方法来做具体的业务逻辑。</p>
<p>下面这段代码是当服务器发现丢失了三个心跳包以后直接关闭客户端的连接<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-06/5be16979352b7.png" alt=""></p>
<h3 id="断线重连">断线重连</h3>
<p>断线重连的逻辑主要是实现在客户端代码这边<strong>ChannelInactive</strong>方法</p>
<p><img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-06/5be169f378c3b.png" alt=""></p>
<h4 id="测试">测试</h4>
<p>我们可以看到，每经过3个丢失的包，服务器便会主动断开客户端的连接；然后客户端知道自己被断开后，会间隔5秒尝试连接服务器，直到成功为止。</p>
<p><img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-06/5be16b2d3febe.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[dotnettty大包与粘包]]></title>
        <id>https://xiwan.github.io/post/dotnettty-da-bao-yu-nian-bao</id>
        <link href="https://xiwan.github.io/post/dotnettty-da-bao-yu-nian-bao">
        </link>
        <updated>2019-08-07T11:04:11.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="目的">目的</h4>
<p>主要测试dotnetty在大包体，或者粘包情况下的表现</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="目的">目的</h4>
<p>主要测试dotnetty在大包体，或者粘包情况下的表现</p>
<!-- more -->
<h4 id="测试">测试</h4>
<h5 id="准备数据">准备数据</h5>
<p>代码部分：</p>
<pre><code class="language-csharp">var requestData = new RequestData();
requestData.Type = 0x0010;
for (int i = 0; i &lt; 256; i++)
{
	requestData.VarTable.Add(i.ToString());
}

var bytes = SerializationHelper.Serialize(requestData);
Console.WriteLine(ByteBufferUtil.HexDump(bytes));
Console.WriteLine(bytes.Length);
</code></pre>
<p>执行程序后内容长度为1172，算上包头和ticket部分，最终为1180长度，其中包头值为1176=0x498</p>
<pre><code>00000498000000010810120130120131120132120133120134120135120136120137120138120139120231301202313112023132120231331202313412023135120231361202313712023138120231391202323012023231120232321202323312023234120232351202323612023237120232381202323912023330120233311202333212023333120233341202333512023336120233371202333812023339120234301202343112023432120234331202343412023435120234361202343712023438120234391202353012023531120235321202353312023534120235351202353612023537120235381202353912023630120236311202363212023633120236341202363512023636120236371202363812023639120237301202373112023732120237331202373412023735120237361202373712023738120237391202383012023831120238321202383312023834120238351202383612023837120238381202383912023930120239311202393212023933120239341202393512023936120239371202393812023939120331303012033130311203313032120331303312033130341203313035120331303612033130371203313038120331303912033131301203313131120331313212033131331203313134120331313512033131361203313137120331313812033131391203313230120331323112033132321203313233120331323412033132351203313236120331323712033132381203313239120331333012033133311203313332120331333312033133341203313335120331333612033133371203313338120331333912033134301203313431120331343212033134331203313434120331343512033134361203313437120331343812033134391203313530120331353112033135321203313533120331353412033135351203313536120331353712033135381203313539120331363012033136311203313632120331363312033136341203313635120331363612033136371203313638120331363912033137301203313731120331373212033137331203313734120331373512033137361203313737120331373812033137391203313830120331383112033138321203313833120331383412033138351203313836120331383712033138381203313839120331393012033139311203313932120331393312033139341203313935120331393612033139371203313938120331393912033230301203323031120332303212033230331203323034120332303512033230361203323037120332303812033230391203323130120332313112033231321203323133120332313412033231351203323136120332313712033231381203323139120332323012033232311203323232120332323312033232341203323235120332323612033232371203323238120332323912033233301203323331120332333212033233331203323334120332333512033233361203323337120332333812033233391203323430120332343112033234321203323433120332343412033234351203323436120332343712033234381203323439120332353012033235311203323532120332353312033235341203323535
</code></pre>
<h5 id="执行测试-大包">执行测试 - 大包</h5>
<p>获取到第一个包1024<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa175c79a8.png" alt=""></p>
<p>获取到第二个包体后，可以看到buffer自动扩充到了2k，其中前1180为传输内容，符合预期<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa1bd3498c.png" alt=""></p>
<p>执行结果<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa470a413a.png" alt=""></p>
<p>由于默认的1k得不到满足，所以每条消息到来都需要重新申请2k的内存，从而更快的消耗内存导致gc<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa3fc5abd5.png" alt=""></p>
<h5 id="执行测试-粘包">执行测试 - 粘包</h5>
<p>制作一个大概1335长度(1180+155)的包体进行发送， 扩充后内存情况如下<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa9822d1c0.png" alt=""></p>
<p>读取完第一个包体后，可以看到ridx=1180<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaa9b8594cb.png" alt=""></p>
<p>开始第二个包体前半部分读取,ridx=0，读取剩下的155长度数据<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-01/5bdaaa5d398f9.png" alt=""></p>
<p>由于tcp可以保持包的顺序，所以只要等待下一个包体到来就可以完成第二个包体的读取了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[serilog vs log4net]]></title>
        <id>https://xiwan.github.io/post/serilog-vs-log4net</id>
        <link href="https://xiwan.github.io/post/serilog-vs-log4net">
        </link>
        <updated>2019-08-07T10:58:59.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="目的">目的</h3>
<p>通过测试数值来比较两个库的优劣</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="目的">目的</h3>
<p>通过测试数值来比较两个库的优劣</p>
<!-- more -->
<h3 id="场景">场景</h3>
<h4 id="login-接口带业务">Login 接口（带业务）</h4>
<p>参数： 线程250， 时间20分钟， 队列长度：5w, 队列读取间隔： 1s， 不做合并写<br>
数据：<br>
0000001c00000003088080b807120464646464120012054465627567</p>
<p>log4net:<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-19/5bf26878b66af.png" alt=""></p>
<p>serilog:<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-19/5bf268d599233.png" alt=""></p>
<p>相同参数：队列积压：4k-5k区间， cpu: 300%, mem: 4% 都是差不多的。<br>
差异参数：偏差值: serilog(8.64) &lt; log4net(13.28), 吞吐量serilog也优秀5%左右。</p>
<h4 id="hearbeat-接口">hearbeat 接口</h4>
<p>参数： 线程3000， 时间20分钟， 队列长度：5w, 队列读取间隔： 1s， 不做合并写<br>
数据：<br>
000000130000000108ffffff07120130120131</p>
<p>log4net:<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-19/5bf2759097410.png" alt=""></p>
<p>serilog:<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-19/5bf26d2ba7bdb.png" alt=""></p>
<p>相同参数：cpu: 300%； mem: 4%；都是差不多的。<br>
差异参数：队列积压：serilog(25-30k), log4net(40k+)；；吞吐量:serilog(2.6w)， log4net(1.5w)；偏差值：serilog(33.42), log4net(17.78)</p>
<h3 id="观察">观察</h3>
<p>在低压力（上千并发）情况下： log4net和serilog的差距不是很明显。</p>
<p>在高压力（上万并发）情况下：这里log4net由于写的并发不高，导致它的吞吐也是一个慢慢爬坡的过程，并且队列积压严重（超过80%）；相反serilog对于写的优秀支持，它可以很快的到达吞吐并发，队列积压只有log4net的一半左右。</p>
<h3 id="延申">延申</h3>
<p>再日志放大10倍的压力下，serilog的效率和log4net差不多，都降到了1万每秒，并且有10%的错误率。原因是这个时候，大家都已经把队列撑爆了，这个时候的瓶颈就是队列了。那么通过调整参数得出下表</p>
<table>
<thead>
<tr>
<th>serilog</th>
<th>tps</th>
<th>错误率</th>
<th>队列积压 (5w)</th>
<th>预估能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>10条</td>
<td>1.1w/s</td>
<td>10%</td>
<td>5w</td>
<td>-</td>
</tr>
<tr>
<td>3条</td>
<td>2.1w/s</td>
<td>0.6%</td>
<td>5w</td>
<td>-</td>
</tr>
<tr>
<td>2条</td>
<td>2.5w/s</td>
<td>0.01%</td>
<td>4.1w</td>
<td>5w/s</td>
</tr>
<tr>
<td>1条</td>
<td>2.5w/s</td>
<td>0%</td>
<td>2.5w</td>
<td>2.3w/s</td>
</tr>
</tbody>
</table>
<p>从这里看出，再队列预设5w长度情况下，serilog可以到达5w/s(但并不是它的峰值)。这么看来后续需要加长队列继续测试：</p>
<p>10w队列</p>
<table>
<thead>
<tr>
<th>serilog</th>
<th>tps</th>
<th>错误率</th>
<th>队列积压</th>
<th>预估能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>10条</td>
<td>1.3w/s</td>
<td>10%</td>
<td>10w</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>20w队列</p>
<table>
<thead>
<tr>
<th>serilog</th>
<th>tps</th>
<th>错误率</th>
<th>队列积压</th>
<th>预估能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>10条</td>
<td>1.6w/s</td>
<td>1%</td>
<td>16w</td>
<td>15w/s</td>
</tr>
</tbody>
</table>
<p>100w队列</p>
<table>
<thead>
<tr>
<th>serilog</th>
<th>tps</th>
<th>错误率</th>
<th>队列积压</th>
<th>预估能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>10条</td>
<td>1.8w/s</td>
<td>0.03%</td>
<td>2w</td>
<td>18w/s</td>
</tr>
</tbody>
</table>
<p>所以可以预估在内存充足的情况下serilog的写入能力为15w-18w之间</p>
<p>网上另一位测试者的结果也侧面证明了我的结果<br>
<img src="http://192.168.1.153/showdoc/server/../Public/Uploads/2018-11-20/5bf3b95b2663c.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于docker搭建centos模板环境]]></title>
        <id>https://xiwan.github.io/post/JMW1yxHv1</id>
        <link href="https://xiwan.github.io/post/JMW1yxHv1">
        </link>
        <updated>2019-08-07T08:29:00.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>我们已经基于标准shell建立了一整套服务器环境搭建体系，在平常运维中，其实只要记住那一步执行哪个shell脚本就好了。但是执行了一段时间后，还是觉得不够灵活。想象如下场景：有一天你刚回收完一套环境，这个时候来了个需求需要尽快搭建一套独立环境之类。这个时候需要重新执行一次所有的脚本，时间比较慢，并且数据可靠性也无法保证。这个时候我想到了docker，虽然我们有在测试环境部分使用它的功能，但并没有真正拿他做到<strong>开箱即用</strong></p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>我们已经基于标准shell建立了一整套服务器环境搭建体系，在平常运维中，其实只要记住那一步执行哪个shell脚本就好了。但是执行了一段时间后，还是觉得不够灵活。想象如下场景：有一天你刚回收完一套环境，这个时候来了个需求需要尽快搭建一套独立环境之类。这个时候需要重新执行一次所有的脚本，时间比较慢，并且数据可靠性也无法保证。这个时候我想到了docker，虽然我们有在测试环境部分使用它的功能，但并没有真正拿他做到<strong>开箱即用</strong></p>
<!-- more -->
<p>以下的流程只是一个测试例子，真实环境需要对不同环境来写不同的镜像。由于我比较懒，所以暂且把所有服务都放在一个镜像里面。</p>
<h1 id="基本流程">基本流程</h1>
<ol>
<li>基于centos 镜像</li>
<li>准备环境的镜像</li>
<li>导出镜像/容器</li>
</ol>
<h1 id="基于centos镜像">基于centos镜像</h1>
<p>这个比较简单，可以到docker hub上面找centos:7， 然后编写dockerfile</p>
<pre><code>FROM centos:7 AS s1
ENV container docker
RUN (cd /lib/systemd/system/sysinit.target.wants/; for i in *; do [ $i == \
systemd-tmpfiles-setup.service ] || rm -f $i; done); \
rm -f /lib/systemd/system/multi-user.target.wants/*;\
rm -f /etc/systemd/system/*.wants/*;\
rm -f /lib/systemd/system/local-fs.target.wants/*; \
rm -f /lib/systemd/system/sockets.target.wants/*udev*; \
rm -f /lib/systemd/system/sockets.target.wants/*initctl*; \
rm -f /lib/systemd/system/basic.target.wants/*;\
rm -f /lib/systemd/system/anaconda.target.wants/*;
VOLUME [ &quot;/data/game&quot; ]
CMD [&quot;/usr/sbin/init&quot;]
</code></pre>
<p>这里主要设置的就是根据不同环境而挂载的VOLUME。目的是为了让镜像无状态化，中间的数据都需要存储到宿主机。</p>
<h1 id="制作环境准备的镜像">制作环境准备的镜像</h1>
<p>上一步只是完成了一些最基本的设置，接下来需要按照应用或者游戏需要应用到的服务来安装和启动。</p>
<ol>
<li>安装网络和设置yum源（通常已经有了）</li>
<li>更新yum</li>
<li>安装软件</li>
<li>配置端口</li>
</ol>
<p>s2依赖于s1</p>
<pre><code>FROM allinone:s1 AS s2
USER root
RUN yum -y install net-tools \
  &amp;&amp; yum -y install wget \
  &amp;&amp; yum remove epel-release \
  &amp;&amp; wget https://mirrors.ustc.edu.cn/epel//7/x86_64/Packages/e/epel-release-7-11.noarch.rpm \
  &amp;&amp; rpm -ivh epel-release-7-11.noarch.rpm \
  &amp;&amp; yum clean all \
  &amp;&amp; yum makecache \
  # update热更新
  &amp;&amp; yum provides '*/applydeltarpm' \ 
  &amp;&amp; yum install deltarpm -y \
  &amp;&amp; yum -y update \
  # 安装sshpass
  &amp;&amp; yum -y install sshpass \
  # 安装subversion
  &amp;&amp; yum -y install subversion \
  # 安装xinetd
  &amp;&amp; yum -y install xinetd \
  #&amp;&amp; yum -y install ntpd \
  &amp;&amp; yum -y install rsync \
  &amp;&amp; yum install -y unzip zip \
  &amp;&amp; yum -y install crontabs

CMD [&quot;/usr/sbin/init&quot;]
</code></pre>
<p>s3又依赖于s2</p>
<pre><code>FROM allinone:s2 AS s3
USER root
RUN yum -y install nginx \
  # 安装supervisor
  &amp;&amp; yum -y install python-setuptools \
  &amp;&amp; easy_install supervisor \
  # 安装 redis
  &amp;&amp; yum -y install redis \
  # 安装 mysql
  &amp;&amp; wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm \
  &amp;&amp; rpm -ivh mysql-community-release-el7-5.noarch.rpm \
  &amp;&amp; yum -y install mysql-community-server \
  &amp;&amp; yum -y install mysql-community-client \
  # 安装 dotnet
  &amp;&amp; rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm \
  &amp;&amp; yum update \
  &amp;&amp; yum -y install aspnetcore-runtime-2.1 \
  &amp;&amp; yum -y install dotnet-sdk-2.1

EXPOSE 80 3306 6379 7000 8001 8009 8010 8011 8012 8013
CMD [&quot;/usr/sbin/init&quot;]
</code></pre>
<p>这里要注意的是，<strong>我们不能在此步骤种进行任何的service或者systemctl之类后台任务的命令</strong>，否则会导致镜像建立的失败。</p>
<p>主要原因是：Docker的设计理念是在容器里面不运行后台服务，容器本身就是宿主机上的一个独立的主进程，也可以间接的理解为就是容器里运行服务的应用进程。一个容器的生命周期是围绕这个主进程存在的，所以正确的使用容器方法是将里面的服务运行在前台。</p>
<p>systemd维护系统服务程序，它需要特权去会访问Linux内核。而容器并不是一个完整的操作系统，只有一个文件系统，而且默认启动只是普通用户这样的权限访问Linux内核，也就是没有特权，所以自然就用不了！</p>
<p>当然我们可以稍后在运行容器时候使用<strong>特权模式</strong>就可以绕开这个问题了。</p>
<p>当我们运行上述dockerfile后，检查镜像列表<br>
<img src="https://xiwan.github.io/post-images/1565169711513.png" alt=""></p>
<p><em>centos:7是最基础的，<br>
然后基于它我们构建了allinone:s1, 由于它并没有实质性的安装任何软件，所以看到大小并没有变化，这里我们可以只是作一些最基础的设置<br>
接下来看allinone:s2，可以看到大小有2G多，这里主要是安装应用需要的软件。在实际运用种可以根据服务器的角色不同而安装不同的软件。</em></p>
<p><em>这里，我们可以把上述所有的dockerfile合并成一个，利用target参数来分步执行。</em></p>
<h1 id="导出镜像容器">导出镜像/容器</h1>
<p>先找到容器 id导出成tar/zip都可以</p>
<pre><code>docker export df5138d2e73d &gt; test.tar
</code></pre>
<p>然后就可以把这个文件上传到公共服务器，其他服务器只需要去拉取这个镜像就可以了</p>
<pre><code>cat test.tar | docker import - allinone:s3
</code></pre>
<p>正如前面描述，由于在镜像生成中无法进行systemctl或者service的后台工作，在实际运用中导出容器比较方便。我们可以在容器中将所有的服务都挂载后台起来后，然后再导出。这样才能做到真正的开箱即用。</p>
<p>不过开箱有一个要注意的地方，需要在run/create 容器命令最后加上对应的CMD(也就是启动命令，而不是简单的bash)<br>
比如：</p>
<pre><code>docker create -v /data/docker/kaki:/data/docker/kaki --privileged=true --name=kakigameserver -p 80:80 -i allinone:s3 /usr/sbin/init
</code></pre>
<h1 id="后续">后续</h1>
<p>可以引入docker-compose这种方案，来优化容器的管理和部属。这样就避免了繁琐的create和start。编排好yml文件后，直接up就可以启动整个容器了。一个例子：</p>
<pre><code>version: '2'
services:
  all-in-one:
    image: &quot;allinone:s3&quot;
    build: ./
    environment:
      - JAVA_OPTS=-Dorg.apache.commons.jelly.tags.fmt.timeZone=Asia/Shanghai 
    ports:
      - 13306:3306
			- 18001:8001
    container_name: docker-test
    privileged: true
    restart: always
    volumes:
        - /data/game:/data/game
    ulimits:
      nproc: 65535
      nofile:
        soft: 20000
        hard: 40000
</code></pre>
<h1 id="参考">参考</h1>
<p><a href="https://yeasy.gitbooks.io/docker_practice/content/compose/commands.html#build">dockerfile</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2d 光照研究]]></title>
        <id>https://xiwan.github.io/post/test</id>
        <link href="https://xiwan.github.io/post/test">
        </link>
        <updated>2019-08-01T09:18:29.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>最近关注了比较多的独立游戏，比如《eastward》，《the last night》和《迷雾侦探》的美术风格一下子吸引了我。经过一些资料的翻阅，发现实现它的美术效果其中很重要的一点就是 <strong>法线贴图</strong>。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>最近关注了比较多的独立游戏，比如《eastward》，《the last night》和《迷雾侦探》的美术风格一下子吸引了我。经过一些资料的翻阅，发现实现它的美术效果其中很重要的一点就是 <strong>法线贴图</strong>。</p>
<!-- more -->
<h2 id="原理">原理</h2>
<p><img src="https://xiwan.github.io/post-images/1564653884231.png" alt=" 原始贴图与法线贴图"></p>
<p>法线图： 基于原始图生成的。这是因为它把图片的法线向量转成了rgp通道。而面向我们的一般是z轴，所以颜色偏蓝。</p>
<pre><code>//下面是两者的互相转换公式
Color.rgb = Normal.xyz / 2.0 + 0.5;
Normal.xyz = Color.rgb * 2.0 - 1.0
</code></pre>
<h2 id="渲染步骤">渲染步骤</h2>
<p>将生成的法线和原图分别贴到材质球上面。接下来就是需要写一些shader了。至于怎么写，其实有很多教程。这里主要说明下基本的渲染步骤：</p>
<pre><code>N = normalize(Normal.xyz)
L = normalize(LightDir.xyz)
Diffuse = LightColor * max(dot(N, L), 0.0)
Ambient = AmbientColor * AmbientIntensity
Attenuation = 1.0 / (ConstantAtt + (LinearAtt * Distance) + (QuadraticAtt * Distance * Distance)) 
Intensity = Ambient + Diffuse * Attenuation
FinalColor = DiffuseColor.rgb * Intensity.rgb
</code></pre>
<h1 id="法线贴图">法线贴图</h1>
<p>这里比较有意思的一点是：这里的序列帧都可以获得该shader效果。</p>
<p><img src="https://s2.ax1x.com/2019/08/02/e0QoSP.gif" alt="e0QoSP.gif"></p>
<h1 id="添加阴影效果">添加阴影效果</h1>
<p>前景虽然看起来不错，但是有一个问题就是没有阴影</p>
<h2 id="阴影效果">阴影效果</h2>
<p><img src="https://s2.ax1x.com/2019/08/02/eBEE6J.gif" alt="eBEE6J.gif"></p>
<h1 id="参考">参考</h1>
<p><a href="https://github.com/mattdesl/lwjgl-basics/wiki/ShaderLesson6">ShaderLesson6</a><br>
<a href="https://zhuanlan.zhihu.com/p/41915682">《迷雾侦探》美术制作过程—光影篇</a></p>
]]></content>
    </entry>
</feed>